<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>4x6 Image Combiner - High Resolution Export</title>
  <style>
    /* Overall Page Styling */
    body {
      background: #f5f7fa;
      margin: 20px;
      font-family: "Helvetica Neue", Arial, sans-serif;
      color: #333;
    }

    /* Card Container */
    .card {
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.1);
      padding: 20px;
      max-width: 900px;
      margin: auto;
    }

    .card h1 {
      margin-top: 0;
      font-size: 1.5em;
      margin-bottom: 20px;
      text-align: center;
    }

    /* Button and Control Bar */
    .buttons-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      margin-bottom: 20px;
    }

    button {
      background: #007bff;
      color: #fff;
      border: none;
      padding: 8px 14px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9em;
      transition: background 0.3s ease;
      outline: none;
    }
    button:hover {
      background: #0069d9;
    }

    /* Upload Section */
    .upload-section {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
    }
    .upload-item {
      display: flex;
      align-items: center;
    }
    .upload-item label {
      display: inline-block;
      min-width: 120px;
      margin-right: 8px;
      font-weight: 500;
    }
    .upload-item input[type="file"] {
      font-size: 0.9em;
    }

    /* Canvas Container */
    #canvasContainer {
      border-radius: 4px;
      border: 1px solid #eaeaea;
      overflow: hidden;
      margin-bottom: 20px;
      text-align: center;
    }

    /* The Preview Canvas */
    #previewCanvas {
      background-color: #f0f0f0;
      cursor: grab;
      display: block;
      margin: 0 auto;
    }
  </style>
</head>
<body>

<div class="card">
  <h1>Photo Editor / High-Resolution Export</h1>

  <!-- Buttons bar -->
  <div class="buttons-bar">
    <button id="orientationBtn">Canvas: Vertical (4×6)</button>
    <button id="lineOrientBtn">Line: Vertical</button>
    <button id="rotateImg1">Rotate Image 1</button>
    <button id="rotateImg2">Rotate Image 2</button>
    <button id="saveBtn">Export Combined Image</button>
  </div>

  <!-- Upload Section -->
  <div class="upload-section">
    <div class="upload-item">
      <label for="file1">Upload Image 1:</label>
      <input type="file" id="file1" accept="image/*" />
    </div>
    <div class="upload-item">
      <label for="file2">Upload Image 2:</label>
      <input type="file" id="file2" accept="image/*" />
    </div>
  </div>

  <!-- Canvas Container -->
  <div id="canvasContainer">
    <canvas id="previewCanvas" width="400" height="600"></canvas>
  </div>
</div>

<script>
/* =========================================
   CONFIG & GLOBALS
========================================= */
const canvas = document.getElementById('previewCanvas');
const ctx = canvas.getContext('2d');

const orientationBtn = document.getElementById('orientationBtn');
const lineOrientBtn = document.getElementById('lineOrientBtn');
const file1 = document.getElementById('file1');
const file2 = document.getElementById('file2');
const saveBtn = document.getElementById('saveBtn');
const rotateImg1Btn = document.getElementById('rotateImg1');
const rotateImg2Btn = document.getElementById('rotateImg2');

// Orientation & line-split
let orientation = 'vertical';   // 'vertical' => 4×6, 'horizontal' => 6×4
let lineOrientation = 'vertical'; // 'vertical' => side-by-side, 'horizontal' => top/bottom

// Canvas dimensions (preview)
const dimensions = {
  vertical:   { w: 400, h: 600 },  // 4×6
  horizontal: { w: 600, h: 400 }   // 6×4
};

/*
Each image: {
  img,       // the HTMLImageElement (full resolution)
  x, y,      // top-left position in the PREVIEW canvas space
  scale,     // scale factor (1 = full original dimension in the PREVIEW)
  angle,     // rotation in degrees
}
*/
const images = [
  { img: null, x: 0, y: 0, scale: 1, angle: 0 }, // Image 0
  { img: null, x: 0, y: 0, scale: 1, angle: 0 }  // Image 1
];

// Drag states
let dragging = false;
let dragIndex = null;
let offsetX = 0;
let offsetY = 0;

/* =========================================
   INIT & UTILS
========================================= */
/**
 * Sets the PREVIEW canvas size based on orientation (4x6 or 6x4).
 */
function updateCanvasSize() {
  const { w, h } = (orientation === 'vertical')
    ? dimensions.vertical
    : dimensions.horizontal;
  
  canvas.width = w;
  canvas.height = h;

  // Adjust container
  const container = canvas.parentElement;
  container.style.width = w + 'px';
  container.style.height = h + 'px';

  draw();
}

/**
 * Auto-fit a newly uploaded (or newly rotated) image
 * into its half (PREVIEW). This ensures it is entirely visible
 * and centered in that half of the preview canvas.
 *
 * We ignore rotation when computing the scale to fit the raw image,
 * then re-apply the angle afterward.
 */
function autoFitImage(index) {
  const imgData = images[index];
  const img = imgData.img;
  if (!img) return;

  const savedAngle = imgData.angle;
  imgData.angle = 0; // temporarily ignore rotation for size calc

  // We'll figure out the bounding region for that half in the preview
  const region = getRegionBounds(index);

  // The raw image size
  const iw = img.width;
  const ih = img.height;

  // The region's width/height
  const regionW = region.w;
  const regionH = region.h;

  // Fit scale to ensure the entire raw (unrotated) image fits
  const scaleX = regionW / iw;
  const scaleY = regionH / ih;
  const fitScale = Math.min(scaleX, scaleY);

  // Put that in imgData
  imgData.scale = fitScale;

  // Scaled width/height
  const scaledW = iw * fitScale;
  const scaledH = ih * fitScale;

  // Center in region
  const centerX = region.x + regionW / 2;
  const centerY = region.y + regionH / 2;
  imgData.x = centerX - scaledW / 2;
  imgData.y = centerY - scaledH / 2;

  // restore the angle
  imgData.angle = savedAngle;
}

/**
 * The bounding region for the half (0 => left/top, 1 => right/bottom)
 * in the PREVIEW canvas. Returns { x, y, w, h }
 */
function getRegionBounds(index) {
  const w = canvas.width;
  const h = canvas.height;
  const lineWidth = 5;

  if (lineOrientation === 'vertical') {
    // left half => index=0, right half => index=1
    const mid = w / 2;
    if (index === 0) {
      return {
        x: 0,
        y: 0,
        w: mid - lineWidth / 2,
        h: h
      };
    } else {
      return {
        x: mid + lineWidth / 2,
        y: 0,
        w: w - (mid + lineWidth / 2),
        h: h
      };
    }
  } else {
    // horizontal => top => index=0, bottom => index=1
    const mid = h / 2;
    if (index === 0) {
      return {
        x: 0,
        y: 0,
        w: w,
        h: mid - lineWidth / 2
      };
    } else {
      return {
        x: 0,
        y: mid + lineWidth / 2,
        w: w,
        h: h - (mid + lineWidth / 2)
      };
    }
  }
}

/**
 * Handle file upload -> create a new HTMLImageElement -> store in images[].
 * Then auto-fit for the preview.
 */
function handleFile(input, index) {
  if (!input.files || !input.files[0]) return;

  const reader = new FileReader();
  reader.onload = (e) => {
    const img = new Image();
    img.onload = () => {
      images[index].img = img;
      // Reset transformations
      images[index].angle = 0;
      images[index].scale = 1;
      // Auto-fit to its half
      autoFitImage(index);
      draw();
    };
    img.src = e.target.result;
  };
  reader.readAsDataURL(input.files[0]);
}

/* =========================================
   DRAW LOGIC IN PREVIEW
========================================= */
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 5px white line
  ctx.save();
  ctx.fillStyle = 'white';
  if (lineOrientation === 'vertical') {
    const mid = canvas.width / 2;
    ctx.fillRect(mid - 2.5, 0, 5, canvas.height);
  } else {
    const mid = canvas.height / 2;
    ctx.fillRect(0, mid - 2.5, canvas.width, 5);
  }
  ctx.restore();

  // Draw each image clipped to its half
  ctx.save();
  clipRegion(0);
  drawSingleImage(0);
  ctx.restore();

  ctx.save();
  clipRegion(1);
  drawSingleImage(1);
  ctx.restore();
}

/**
 * Clipping region for image index
 */
function clipRegion(index) {
  const { x, y, w, h } = getRegionBounds(index);
  ctx.beginPath();
  ctx.rect(x, y, w, h);
  ctx.closePath();
  ctx.clip();
}

/**
 * Draw one image with x,y,scale,angle
 */
function drawSingleImage(i) {
  const data = images[i];
  if (!data.img) return;

  ctx.save();
  ctx.translate(data.x, data.y);
  ctx.rotate(data.angle * Math.PI / 180);
  ctx.scale(data.scale, data.scale);
  ctx.drawImage(data.img, 0, 0);
  ctx.restore();
}

/* =========================================
   DRAG & ZOOM ON PREVIEW
========================================= */
canvas.addEventListener('mousedown', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  // from top-most image down
  for (let i = images.length - 1; i >= 0; i--) {
    const { img, x, y, scale, angle } = images[i];
    if (!img) continue;

    // Convert mouse to unrotated/unscaled coords
    const cosA = Math.cos(angle * Math.PI / 180);
    const sinA = Math.sin(angle * Math.PI / 180);
    const dx = mouseX - x;
    const dy = mouseY - y;
    let rx = dx * cosA + dy * sinA;
    let ry = -dx * sinA + dy * cosA;
    rx /= scale;
    ry /= scale;

    if (rx >= 0 && rx <= img.width && ry >= 0 && ry <= img.height) {
      dragging = true;
      dragIndex = i;
      offsetX = dx;
      offsetY = dy;
      break;
    }
  }
});

canvas.addEventListener('mousemove', (e) => {
  if (!dragging) return;
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  const imgData = images[dragIndex];
  imgData.x = mouseX - offsetX;
  imgData.y = mouseY - offsetY;
  draw();
});

canvas.addEventListener('mouseup', () => {
  dragging = false;
  dragIndex = null;
});

// Scroll => zoom
canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  for (let i = images.length - 1; i >= 0; i--) {
    const data = images[i];
    const { img, x, y, scale, angle } = data;
    if (!img) continue;

    const cosA = Math.cos(angle * Math.PI / 180);
    const sinA = Math.sin(angle * Math.PI / 180);
    const dx = mouseX - x;
    const dy = mouseY - y;
    
    let rx = dx * cosA + dy * sinA;
    let ry = -dx * sinA + dy * cosA;
    rx /= scale;
    ry /= scale;

    if (rx >= 0 && rx <= img.width && ry >= 0 && ry <= img.height) {
      const zoomFactor = e.deltaY > 0 ? 0.95 : 1.05;
      const oldScale = data.scale;
      data.scale = Math.max(0.05, Math.min(10, data.scale * zoomFactor));

      const factor = data.scale / oldScale;
      data.x = mouseX - factor * (mouseX - data.x);
      data.y = mouseY - factor * (mouseY - data.y);

      draw();
      break;
    }
  }
}, { passive: false });

/* =========================================
   BUTTON HANDLERS
========================================= */
orientationBtn.addEventListener('click', () => {
  orientation = (orientation === 'vertical') ? 'horizontal' : 'vertical';
  orientationBtn.textContent = (orientation === 'vertical')
    ? 'Canvas: Vertical (4×6)'
    : 'Canvas: Horizontal (6×4)';
  updateCanvasSize();
});

lineOrientBtn.addEventListener('click', () => {
  lineOrientation = (lineOrientation === 'vertical') ? 'horizontal' : 'vertical';
  lineOrientBtn.textContent = (lineOrientation === 'vertical')
    ? 'Line: Vertical'
    : 'Line: Horizontal';
  draw();
});

rotateImg1Btn.addEventListener('click', () => {
  images[0].angle = (images[0].angle + 90) % 360;
  // Re-fit after rotation
  autoFitImage(0);
  draw();
});
rotateImg2Btn.addEventListener('click', () => {
  images[1].angle = (images[1].angle + 90) % 360;
  // Re-fit after rotation
  autoFitImage(1);
  draw();
});

file1.addEventListener('change', () => handleFile(file1, 0));
file2.addEventListener('change', () => handleFile(file2, 1));

/**
 * Clicking "Export Combined Image" => create a large
 * offscreen canvas replicating user transformations in
 * "full resolution" (based on each image’s original pixel size
 * times the user’s scale, etc.), then download a PNG.
 */

saveBtn.addEventListener('click', () => {
  const offscreen = document.createElement('canvas');
  const ctx2 = offscreen.getContext('2d');

  // We’ll compute the final bounding dimensions for the two images
  // based on their "full-resolution" scaled size, plus 5px line.

  // A helper function to get bounding box (width, height) after rotation
  // for an image of size (w,h) rotated by angle:
  function rotatedBoundingBox(w, h, angleDeg) {
    const r = angleDeg * Math.PI / 180;
    const cosA = Math.abs(Math.cos(r));
    const sinA = Math.abs(Math.sin(r));
    return {
      w: w * cosA + h * sinA,
      h: w * sinA + h * cosA
    };
  }

  // For each image:
  // final scaled width = origWidth * scale
  // final scaled height = origHeight * scale
  // then we compute bounding box if angle != 0
  // We'll also replicate the user’s x,y offsets proportionally.

  // Let’s define a function to gather final data from the preview’s x,y
  // so we can shift them consistently.
  function getFinalInfo(i) {
    const { img, x, y, scale, angle } = images[i];
    if (!img) return null;
    // bounding box for rotation
    const box = rotatedBoundingBox(img.width * scale, img.height * scale, angle);
    return {
      angle,
      scale,
      width: img.width,
      height: img.height,
      boundingW: box.w,
      boundingH: box.h,
      previewX: x,
      previewY: y
    };
  }

  const info0 = getFinalInfo(0);
  const info1 = getFinalInfo(1);

  if (!info0 && !info1) {
    alert("No images to export!");
    return;
  }

  // The preview canvas size:
  const previewW = canvas.width;
  const previewH = canvas.height;

  // We'll track how large the offscreen canvas should be:
  let offW = 0;
  let offH = 0;

  // For line orientation "vertical": place image0 on the left, image1 on the right
  // final width = boundingW0 + boundingW1 + 5
  // final height = max(boundingH0, boundingH1)
  // For line orientation "horizontal": stacked top/bottom
  if (lineOrientation === 'vertical') {
    offW = 0; 
    offH = 0;
    if (info0) offW += info0.boundingW;
    if (info1) offW += info1.boundingW;
    offW += 5; // line
    offH = Math.max(info0 ? info0.boundingH : 0, info1 ? info1.boundingH : 0);
  } else {
    // horizontal
    offW = Math.max(info0 ? info0.boundingW : 0, info1 ? info1.boundingW : 0);
    offH = 0;
    if (info0) offH += info0.boundingH;
    if (info1) offH += info1.boundingH;
    offH += 5; // line
  }

  // Round up for safety
  offscreen.width = Math.ceil(offW);
  offscreen.height = Math.ceil(offH);

  // Fill background
  ctx2.fillStyle = "#ffffff";
  ctx2.fillRect(0, 0, offscreen.width, offscreen.height);

  // Draw the line
  ctx2.save();
  ctx2.fillStyle = 'white';
  if (lineOrientation === 'vertical') {
    // We'll place a vertical line between the two bounding boxes
    // We must figure out where image0 ends and image1 starts.
    let splitX = info0 ? info0.boundingW : 0;
    // place a 5px line
    ctx2.fillRect(splitX, 0, 5, offscreen.height);
  } else {
    // horizontal line
    let splitY = info0 ? info0.boundingH : 0;
    ctx2.fillRect(0, splitY, offscreen.width, 5);
  }
  ctx2.restore();

  /**
   * Helper: draw one image into ctx2 at “full resolution” 
   *   offsetX, offsetY => where we place the top-left bounding box
   *   (in the final big canvas).
   */
  function drawImageFull(i, offsetX, offsetY) {
    const { img, x, y, scale, angle } = images[i];
    // The user’s x,y is in preview coordinates =>  
    // we want to replicate that offset proportionally in final. 
    // If previewW = 400 but final bounding box is e.g. info0.boundingW,
    // we can interpret that ratio. 
    // A simple solution:
    //   finalX = offsetX + (x / previewW) * (some factor)
    // But we want the *exact same relative position* the user sees in the preview.
    //
    // The simplest approach is to interpret scale=1 as “draw the image at its full raw dimension.” 
    // Then the user’s x,y in preview is scaled up by the factor 
    //   (img.width * scale) / (img.width * scale in preview).
    // But in the preview, “img.width * scale” is displayed in some fraction of  (regionW).
    //
    // To keep it straightforward, let’s define:
    //   ratioX = offscreen.width / previewW
    //   ratioY = offscreen.height / previewH
    // Then finalX = (x) * ratioX, finalY = (y) * ratioY
    // This is a coarse approach if the images are partially overlapping or if the line orientation changes the partial bounding. 
    // But it’s a workable demonstration. 
    // For more robust logic, we’d replicate the EXACT 2D transform from the preview.

    const ratioX = (lineOrientation === 'vertical') 
      ? (info0 && info1) 
        ? (info0.boundingW + info1.boundingW + 5) / previewW
        : offscreen.width / previewW
      : offscreen.width / previewW;

    const ratioY = (lineOrientation === 'horizontal')
      ? (info0 && info1)
        ? (info0.boundingH + info1.boundingH + 5) / previewH
        : offscreen.height / previewH
      : offscreen.height / previewH;

    // The scaled offset from the user’s transforms
    const finalX = offsetX + x * ratioX;
    const finalY = offsetY + y * ratioY;

    // Now draw
    ctx2.save();
    ctx2.translate(finalX, finalY);
    ctx2.rotate(angle * Math.PI / 180);

    // scale in final = (original dimension) * scale
    // But we also multiply by ratioX for consistency with user’s overall preview
    // so it “positions” similarly.
    const finalScaleX = scale * ratioX;
    const finalScaleY = scale * ratioY;

    ctx2.scale(finalScaleX, finalScaleY);
    ctx2.drawImage(img, 0, 0);
    ctx2.restore();
  }

  // Actually draw image 0 and image 1:
  let currentOffsetX = 0;
  let currentOffsetY = 0;

  if (lineOrientation === 'vertical') {
    // place image0 at offsetX=0, image1 at offsetX=(info0? info0.boundingW : 0)+5
    if (info0) {
      drawImageFull(0, 0, 0);
    }
    if (info1) {
      drawImageFull(1, (info0 ? info0.boundingW : 0) + 5, 0);
    }
  } else {
    // horizontal => top/bottom
    if (info0) {
      drawImageFull(0, 0, 0);
    }
    if (info1) {
      drawImageFull(1, 0, (info0 ? info0.boundingH : 0) + 5);
    }
  }

  // Export
  const dataURL = offscreen.toDataURL('image/png');
  const link = document.createElement('a');
  link.download = 'combined.png';
  link.href = dataURL;
  link.click();
});

/* =========================================
   INITIAL SETUP
========================================= */
updateCanvasSize();
draw();
</script>
</body>
</html>
