<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" /> <!-- Character set -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/> <!-- Responsive scaling -->
  <title>Critical Path Tracer</title>
  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"/>
  <!-- PapaParse for CSV parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <style>
    body { 
      padding: 1.5rem; 
      background-color: #f8f9fa; 
      font-size: 0.9rem; 
    }
    .log-container { 
      max-height: 150px; 
      overflow-y: auto; 
      background: #f1f1f1; 
      padding: 8px; 
      border-radius: 5px; 
      font-family: monospace; 
      font-size: 0.8rem; 
    }
    .activity-card { 
      cursor: pointer; 
      transition: 0.2s; 
    }
    .activity-card:hover { 
      background-color: #e9ecef; 
    }
    .critical-path-list { 
      min-height: 80px; 
    }
    .search-results { 
      max-height: 200px; 
      overflow-y: auto; 
    }
    .sortable { 
      cursor: pointer; 
    }
    .sortable::after { 
      content: ' [sort]'; 
      font-size: 0.75em; 
      color: #666; 
    }
    .sortable.sort-asc::after { 
      content: ' [asc]'; 
      font-size: 0.75em; 
      color: #666; 
    }
    .sortable.sort-desc::after { 
      content: ' [desc]'; 
      font-size: 0.75em; 
      color: #666; 
    }
    .predecessor-table th, .predecessor-table td { 
      font-size: 0.8rem; 
      padding: 4px; 
    }
    .final-path-table th, .final-path-table td { 
      font-size: 0.8rem; 
      padding: 4px; 
    }
    .card { 
      margin-bottom: 1rem; 
    }
    .card-body { 
      padding: 0.75rem; 
    }
    .card-header { 
      padding: 0.5rem 0.75rem; 
      font-size: 0.9rem; 
    }
    .table-sm th, .table-sm td { 
      padding: 0.25rem; 
    }
    .btn-sm { 
      padding: 0.15rem 0.3rem; 
      font-size: 0.75rem; 
    }
  </style>
</head>
<body>
  <div class="container-fluid">
    <h1 class="mb-3 text-primary">Critical Path Tracer</h1>
    <div class="row g-3">
      <!-- Left Column: Upload + Search + Tracing -->
      <div class="col-lg-7">
        <!-- Upload -->
        <div class="card shadow-sm">
          <div class="card-header bg-primary text-white">
            <h6 class="mb-0">1. Upload Schedule (CSV)</h6>
          </div>
          <div class="card-body">
            <!-- Input for CSV upload -->
            <input 
              type="file" 
              id="csvUpload" 
              accept=".csv" 
              class="form-control form-control-sm"
              aria-label="Upload your schedule CSV file here to begin"
            />
            <small class="text-muted">Headers: Activity ID, Start, Finish, Predecessors, Predecessor Details...</small>
          </div>
        </div>

        <!-- Search -->
        <div class="card shadow-sm" id="searchSection" style="display:none;">
          <div class="card-header bg-success text-white">
            <h6 class="mb-0">2. Start Tracing</h6>
          </div>
          <div class="card-body">
            <!-- Input for searching activities -->
            <input 
              type="text" 
              id="activitySearch" 
              class="form-control form-control-sm mb-2" 
              placeholder="Search ID or Name..."
              aria-label="Search activities by ID or name"
            />
            <!-- Results area for search matches -->
            <div id="searchResults" class="search-results border p-2 bg-white small"></div>
          </div>
        </div>

        <!-- Tracing Area -->
        <div class="card shadow-sm" id="traceSection" style="display:none;">
          <div class="card-header bg-warning text-dark">
            <h6 class="mb-0">3. Click Predecessor to Add</h6>
          </div>
          <div class="card-body">
            <!-- Dynamic predecessor listing -->
            <div id="predecessorList" class="mb-2"></div>
          </div>
        </div>
      </div>

      <!-- Right Column: Output + Log -->
      <div class="col-lg-5">
        <!-- Final Output -->
        <div class="card shadow-sm">
          <div class="card-header bg-info text-white">
            <h6 class="mb-0">Final Critical Path</h6>
          </div>
          <div class="card-body">
            <!-- Table listing the final critical path -->
            <table class="table table-sm table-hover final-path-table mb-2">
              <thead>
                <tr>
                  <th>ID</th>
                  <th>Name</th>
                  <th>Start</th>
                  <th>Finish</th>
                  <th>Total Float</th>
                  <th></th>
                </tr>
              </thead>
              <tbody id="criticalPathList"></tbody>
            </table>
            <!-- Export button for CSV of final critical path -->
            <button id="exportBtn" class="btn btn-success w-100 btn-sm" disabled>Export CSV</button>
            <!-- Undo/Redo buttons -->
            <div class="d-flex gap-2 mt-2">
              <!-- Undo button -->
              <button id="undoBtn" class="btn btn-secondary btn-sm w-50" disabled>Undo</button>
              <!-- Redo button -->
              <button id="redoBtn" class="btn btn-secondary btn-sm w-50" disabled>Redo</button>
            </div>
          </div>
        </div>

        <!-- Log -->
        <div class="card shadow-sm">
          <div class="card-header bg-dark text-white">
            <h6 class="mb-0">Log</h6>
          </div>
          <div class="card-body p-0">
            <!-- Text area for logs -->
            <pre id="log" class="log-container m-0 p-2"></pre>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap JS bundle -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    // Global data
    let activities = []; // Full parsed data from CSV
    let activityMap = {}; // Map of Activity ID → object
    let criticalPath = []; // Final ordered list for critical path
    let predSortField = 'Activity Status'; // Default sort field
    let predSortAsc = true; // Default: ascending for the sort

    // History for Undo/Redo
    let historyStack = []; // Stack for previous states
    let redoStack = [];    // Stack for undone states

    // DOM Elements
    const csvUpload = document.getElementById('csvUpload');
    const searchSection = document.getElementById('searchSection');
    const traceSection = document.getElementById('traceSection');
    const activitySearch = document.getElementById('activitySearch');
    const searchResults = document.getElementById('searchResults');
    const predecessorList = document.getElementById('predecessorList');
    const criticalPathList = document.getElementById('criticalPathList');
    const exportBtn = document.getElementById('exportBtn');
    const log = document.getElementById('log');
    const undoBtn = document.getElementById('undoBtn');    // Undo button
    const redoBtn = document.getElementById('redoBtn');    // Redo button

    // Log helper function: appends messages with a timestamp
    function addLog(message) {
      const timestamp = new Date().toLocaleTimeString();
      log.innerHTML += `[${timestamp}] ${message}\n`;
      log.scrollTop = log.scrollHeight;
    }

    // Utility to clean date strings: remove " A" and "*" from date strings
    function cleanDate(dateStr) {
      if (!dateStr) return '';
      return dateStr.toString().replace(/ A/g, '').replace(/\*/g, '').trim();
    }

    /**
     * Checks if required columns exist in the CSV. If not, logs an error and alerts the user.
     * This ensures the necessary columns are present for the script to function.
     */
    function validateColumns(data) {
      // Required columns for the script
      const requiredColumns = ['Activity ID', 'Start', 'Finish', 'Predecessors', 'Predecessor Details'];
      
      // If no data rows are found
      if (data.length === 0) {
        addLog('No data found in CSV.');
        alert('CSV is empty. Please upload a valid file.');
        return false;
      }
      
      // Check if all columns exist in the first row
      const firstRow = Object.keys(data[0]);
      const missingColumns = requiredColumns.filter(col => !firstRow.includes(col));
      
      if (missingColumns.length > 0) {
        addLog('Missing columns: ' + missingColumns.join(', '));
        alert('Some required columns are missing: ' + missingColumns.join(', '));
        return false;
      }
      
      return true;
    }

    // CSV Upload Handler
    csvUpload.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return; // If user didn't select a file, exit

      addLog(`File selected: ${file.name}`);
      // Use worker for better performance on large files
      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        worker: true, // Use Web Worker to avoid blocking the main thread
        complete: (result) => {
          if (result.errors.length) {
            addLog(`Parse errors: ${result.errors.map(er => er.message).join('; ')}`);
            alert('CSV parsing failed. Check log.');
            return;
          }

          // Validate columns after parsing
          if (!validateColumns(result.data)) {
            return; 
          }

          // Clean up activity data (removing " A" and "*" from date strings)
          activities = result.data.map(act => ({
            ...act,
            'Start': cleanDate(act['Start']),
            'Finish': cleanDate(act['Finish'])
          }));

          // Build map of Activity ID → object
          activityMap = {};
          activities.forEach(act => {
            const id = act['Activity ID']?.trim();
            if (id) activityMap[id] = act;
          });

          addLog(`Loaded ${activities.length} activities. Cleaned date artifacts.`);
          // Show search section and reset the trace section
          searchSection.style.display = 'block';
          traceSection.style.display = 'none';
          criticalPath = [];
          updateCriticalPathUI();
          // Re-enable CSV usage
          exportBtn.disabled = (criticalPath.length === 0);
        },
        error: (err) => {
          addLog(`Parse error: ${err}`);
          alert('Failed to parse CSV.');
        }
      });
    });

    // Searching for activities
    activitySearch.addEventListener('input', () => {
      const query = activitySearch.value.trim().toLowerCase();
      searchResults.innerHTML = ''; // Clear old results

      if (!query) return; // If user clears the input, do nothing

      // Match by ID or Name, limit to first 10
      const matches = activities.filter(act => {
        const id = act['Activity ID']?.toLowerCase();
        const name = act['Activity Name']?.toLowerCase();
        return (id && id.includes(query)) || (name && name.includes(query));
      }).slice(0, 10);

      if (matches.length === 0) {
        searchResults.innerHTML = '<div class="text-muted p-1">No activities found.</div>';
        return;
      }

      // Populate search results
      matches.forEach(act => {
        const div = document.createElement('div');
        div.className = 'activity-card p-1 border-bottom small';
        div.innerHTML = `<strong>${act['Activity ID']}</strong> - ${act['Activity Name'] || 'N/A'}`;
        // On click, begin tracing from this activity
        div.onclick = () => startCriticalPath(act);
        searchResults.appendChild(div);
      });
    });

    // Push current state of criticalPath to history (for Undo)
    function pushHistory() {
      // Save a deep copy of the current path
      historyStack.push(JSON.parse(JSON.stringify(criticalPath)));
      // Once a new action is taken, the redo stack should be cleared
      redoStack = [];
      updateUndoRedoButtons();
    }

    // Undo function: revert to the last saved state
    function undo() {
      if (historyStack.length > 0) {
        // Move current state to redo stack
        redoStack.push(JSON.parse(JSON.stringify(criticalPath)));
        // Revert to the last saved state
        criticalPath = historyStack.pop();
        addLog("Undo last action. Reverted to previous state of critical path.");
        updateCriticalPathUI();
        if (criticalPath.length > 0) {
          const lastItem = criticalPath[criticalPath.length - 1];
          showPredecessors(lastItem);
          traceSection.style.display = 'block';
        } else {
          predecessorList.innerHTML = '';
          traceSection.style.display = 'none';
        }
        updateUndoRedoButtons();
      } else {
        alert("No more actions to undo.");
      }
    }

    // Redo function: reapply the last undone state
    function redo() {
      if (redoStack.length > 0) {
        // Save current state to the history before reapplying
        historyStack.push(JSON.parse(JSON.stringify(criticalPath)));
        // Reapply last undone state
        criticalPath = redoStack.pop();
        addLog("Redid last undone action. Re-applied previous critical path state.");
        updateCriticalPathUI();
        if (criticalPath.length > 0) {
          const lastItem = criticalPath[criticalPath.length - 1];
          showPredecessors(lastItem);
          traceSection.style.display = 'block';
        } else {
          predecessorList.innerHTML = '';
          traceSection.style.display = 'none';
        }
        updateUndoRedoButtons();
      } else {
        alert("No more actions to redo.");
      }
    }

    // Enable/disable Undo/Redo buttons
    function updateUndoRedoButtons() {
      undoBtn.disabled = (historyStack.length === 0);
      redoBtn.disabled = (redoStack.length === 0);
    }

    // Start tracing from the selected activity
    function startCriticalPath(startAct) {
      addLog(`Starting trace from: ${startAct['Activity ID']}`);
      criticalPath = [startAct]; // Begin new path
      updateCriticalPathUI();
      showPredecessors(startAct);
      traceSection.style.display = 'block';
      activitySearch.value = '';
      searchResults.innerHTML = '';
      // Save new state to history
      pushHistory();
    }

    // Show the predecessors for the current activity
    function showPredecessors(currentAct) {
      predecessorList.innerHTML = '';
      // Parse Predecessor Details for relationship types
      const predDetails = (currentAct['Predecessor Details'] || '')
        .split(';')
        .map(s => s.trim())
        .filter(Boolean);
      const predMap = {};
      predDetails.forEach(d => {
        const [id, type] = d.split(':');
        if (id && type) predMap[id.trim()] = type.trim();
      });

      // Split Predecessors by comma or semicolon
      const predIds = (currentAct.Predecessors || '')
        .split(/[,;]/)
        .map(s => s.trim())
        .filter(id => id && activityMap[id]);

      if (predIds.length === 0) {
        predecessorList.innerHTML = '<p class="text-muted small">No predecessors.</p>';
        addLog(`Activity ${currentAct['Activity ID']} has no predecessors.`);
        return;
      }

      addLog(`Found ${predIds.length} predecessor(s) for ${currentAct['Activity ID']}.`);

      // Build table structure for predecessors
      const table = document.createElement('table');
      table.className = 'table table-sm table-bordered predecessor-table';
      table.innerHTML = `
        <thead class="table-light">
          <tr>
            <th class="sortable" data-sort="Activity ID">ID</th>
            <th class="sortable" data-sort="Activity Name">Name</th>
            <th class="sortable" data-sort="Start">Start</th>
            <th class="sortable" data-sort="Finish">Finish</th>
            <th class="sortable" data-sort="Total Float">TF</th>
            <th class="sortable" data-sort="Relationship Free Float">RF</th>
            <th class="sortable" data-sort="Primary Constraint">Const</th>
            <th class="sortable" data-sort="Activity Status">Status</th>
            <th>Rel</th>
          </tr>
        </thead>
        <tbody id="predTableBody"></tbody>
      `;

      const tbody = table.querySelector('#predTableBody');
      const headers = table.querySelectorAll('.sortable');

      // Attach click handlers for sortable columns
      headers.forEach(th => {
        th.addEventListener('click', () => {
          // Which field are we sorting by
          const field = th.dataset.sort;

          // Toggle or set ascending/descending
          if (predSortField === field) {
            predSortAsc = !predSortAsc;
          } else {
            predSortField = field;
            predSortAsc = true;
          }

          // Remove old ASC/DESC classes
          headers.forEach(h => {
            h.classList.remove('sort-asc', 'sort-desc');
          });
          th.classList.add(predSortAsc ? 'sort-asc' : 'sort-desc');

          // Re-render rows with the new sort
          renderPredecessorRows(tbody, predIds, predMap);
        });
      });

      // Initial render
      renderPredecessorRows(tbody, predIds, predMap);
      predecessorList.appendChild(table);
    }

    // Our custom sort function, then rendering the table rows
    function renderPredecessorRows(tbody, predIds, predMap) {
      tbody.innerHTML = '';
      let sortedPreds = predIds.map(id => activityMap[id]);

      // For status sorting logic: Not Started => 0, In Progress => 1, Completed => 2
      const statusOrder = { 'Not Started': 0, 'In Progress': 1, 'Completed': 2 };

      // Sort primarily by the requested field if possible, otherwise fallback
      // For example, if user clicks "Activity Name", sort by it
      // Then refine your approach for "Activity Status" or other fields if needed
      // If the chosen field is 'Activity Status', we do special sorting

      sortedPreds.sort((a, b) => {
        let valA = (a[predSortField] || '').trim();
        let valB = (b[predSortField] || '').trim();

        // If sorting by status, use statusOrder
        if (predSortField === 'Activity Status') {
          const orderA = statusOrder[valA] ?? 999;
          const orderB = statusOrder[valB] ?? 999;
          return predSortAsc ? (orderA - orderB) : (orderB - orderA);
        }

        // If sorting by numeric fields
        if (predSortField === 'Total Float' || predSortField === 'Relationship Free Float') {
          const numA = parseFloat(valA) || 0;
          const numB = parseFloat(valB) || 0;
          return predSortAsc ? (numA - numB) : (numB - numA);
        }

        // If sorting by date fields
        if (predSortField === 'Start' || predSortField === 'Finish') {
          const dateA = new Date(valA) || 0;
          const dateB = new Date(valB) || 0;
          return predSortAsc ? (dateA - dateB) : (dateB - dateA);
        }

        // Default: compare as strings
        valA = valA.toLowerCase();
        valB = valB.toLowerCase();
        if (valA < valB) return predSortAsc ? -1 : 1;
        if (valA > valB) return predSortAsc ? 1 : -1;
        return 0;
      });

      // Now populate the rows with appropriate color for "In Progress" or "Completed"
      sortedPreds.forEach(pred => {
        const relType = predMap[pred['Activity ID']] || '—';
        const row = document.createElement('tr');
        row.className = 'activity-card';
        row.style.cursor = 'pointer';

        // Use color to highlight "In Progress" or "Completed"
        // We'll re-use an approach similar to getColorByStatus, but just lighten the row
        let bgColor = '#ffffff'; // default
        const statusStr = (pred['Activity Status'] || '').toLowerCase();
        if (statusStr === 'in progress') {
          // light orange
          bgColor = 'rgba(255, 165, 0, 0.15)';
        } else if (statusStr === 'completed') {
          // light gray
          bgColor = 'rgba(128, 128, 128, 0.15)';
        }
        row.style.backgroundColor = bgColor;

        row.innerHTML = `
          <td><strong>${pred['Activity ID']}</strong></td>
          <td>${pred['Activity Name'] || '—'}</td>
          <td>${pred['Start'] || '—'}</td>
          <td>${pred['Finish'] || '—'}</td>
          <td>${pred['Total Float'] || '—'}</td>
          <td>${pred['Relationship Free Float'] || '—'}</td>
          <td>${pred['Primary Constraint'] || '—'}</td>
          <td>${pred['Activity Status'] || '—'}</td>
          <td>${relType}</td>
        `;
        // On click, add this predecessor to the path
        row.onclick = () => addToCriticalPath(pred);
        tbody.appendChild(row);
      });
    }

    // Adding a predecessor (predAct) into the critical path
    function addToCriticalPath(predAct) {
      // Prevent duplicates in the critical path
      if (criticalPath.some(a => a['Activity ID'] === predAct['Activity ID'])) {
        alert('Already in path.');
        return;
      }

      criticalPath.unshift(predAct);
      addLog(`Added: ${predAct['Activity ID']}`);
      // Save new state to history
      pushHistory();
      // Update UI
      updateCriticalPathUI();
      showPredecessors(predAct);
    }

    // Refresh the critical path UI table
    function updateCriticalPathUI() {
      criticalPathList.innerHTML = '';
      criticalPath.forEach((act, i) => {
        const tr = document.createElement('tr');
        // If in progress or completed, lightly color the row
        let bgColor = '#ffffff';
        const statusStr = (act['Activity Status'] || '').toLowerCase();
        if (statusStr === 'in progress') {
          bgColor = 'rgba(255, 165, 0, 0.15)';
        } else if (statusStr === 'completed') {
          bgColor = 'rgba(128, 128, 128, 0.15)';
        }
        tr.style.backgroundColor = bgColor;

        // Add total float column after Finish
        tr.innerHTML = `
          <td><strong>${act['Activity ID']}</strong></td>
          <td>${act['Activity Name'] || 'N/A'}</td>
          <td>${act['Start'] || 'N/A'}</td>
          <td>${act['Finish'] || 'N/A'}</td>
          <td>${act['Total Float'] || 'N/A'}</td>
          <td>
            <button class="btn btn-sm btn-outline-danger" onclick="removeFromPath(${i})">[Remove]</button>
          </td>
        `;
        criticalPathList.appendChild(tr);
      });
      exportBtn.disabled = (criticalPath.length === 0);
    }

    // Remove an item from the path by index
    window.removeFromPath = (index) => {
      const removed = criticalPath.splice(index, 1)[0];
      addLog(`Removed: ${removed['Activity ID']}`);
      // Save new state to history
      pushHistory();
      // Update UI
      updateCriticalPathUI();

      // If path still has items, revert to last item’s predecessors
      if (criticalPath.length > 0) {
        const lastItem = criticalPath[criticalPath.length - 1];
        showPredecessors(lastItem);
      } else {
        // If no items left, hide the trace section
        predecessorList.innerHTML = '';
        traceSection.style.display = 'none';
      }
    };

    // Export the critical path to a CSV file
    exportBtn.addEventListener('click', () => {
      if (criticalPath.length === 0) return;

      // Restrict columns to these for the output
      const headers = [
        'Project ID', 'Activity ID', 'Activity Name', 'Original Duration', 'At Completion Duration',
        'Remaining Duration', 'Early Start', 'Early Finish', 'Start', 'Finish', 'Late Start', 'Late Finish',
        'Predecessors', 'Successors', 'Activity Status', 'Total Float', 'Activity Type'
      ];

      // Build rows from each activity
      const rows = criticalPath.map(act => headers.map(h => act[h] || ''));

      // Convert rows to CSV string
      let csvContent = headers.join(',') + '\n' + rows.map(r => r.join(',')).join('\n');

      // Create a Blob and download
      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `critical_path_${criticalPath[0]['Activity ID']}_to_${criticalPath[criticalPath.length-1]['Activity ID']}.csv`;
      a.click();
      URL.revokeObjectURL(url);

      addLog(`Exported ${criticalPath.length} activities to CSV.`);
    });

    // Hook up Undo/Redo buttons
    undoBtn.addEventListener('click', undo);
    redoBtn.addEventListener('click', redo);
  </script>
</body>
</html>
