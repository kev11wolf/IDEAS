<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Critical Path Tracer</title>
  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"/>
  <!-- PapaParse for CSV parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <!-- Chart.js for Gantt -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <style>
    body { padding: 2rem; background-color: #f8f9fa; }
    .log-container { max-height: 200px; overflow-y: auto; background: #f1f1f1; padding: 10px; border-radius: 5px; font-family: monospace; font-size: 0.9rem; }
    .activity-card { cursor: pointer; transition: 0.2s; }
    .activity-card:hover { background-color: #e9ecef; }
    .critical-path-list { min-height: 100px; }
    .search-results { max-height: 300px; overflow-y: auto; }
    .sortable { cursor: pointer; }
    .sortable::after { content: ' [sort]'; font-size: 0.8em; color: #666; }
    .gantt-container { height: 300px; margin-top: 20px; }
    .predecessor-table th { font-size: 0.8rem; }
    .predecessor-table td { font-size: 0.85rem; }
    .final-path-table th { font-size: 0.85rem; }
  </style>
</head>
<body>
  <div class="container">
    <h1 class="mb-4 text-primary">Critical Path Tracer</h1>
    <div class="row">
      <div class="col-lg-8">
        <div class="card shadow-sm mb-4">
          <div class="card-header bg-primary text-white">
            <h5 class="mb-0">1. Upload Project Schedule (CSV)</h5>
          </div>
          <div class="card-body">
            <input type="file" id="csvUpload" accept=".csv" class="form-control"/>
            <small class="text-muted">Expected headers: Project ID, Activity ID, Activity Name, Predecessors, etc.</small>
          </div>
        </div>

        <div class="card shadow-sm mb-4" id="searchSection" style="display:none;">
          <div class="card-header bg-success text-white d-flex justify-content-between align-items-center">
            <h5 class="mb-0">2. Select Starting Activity</h5>
            <button id="autoDetectBtn" class="btn btn-outline-light btn-sm" disabled>Auto-Detect Critical Path</button>
          </div>
          <div class="card-body">
            <input type="text" id="activitySearch" class="form-control mb-3" placeholder="Type to search Activity ID or Name..."/>
            <div id="searchResults" class="search-results border p-2 bg-white"></div>
          </div>
        </div>

        <div class="card shadow-sm mb-4" id="traceSection" style="display:none;">
          <div class="card-header bg-warning text-dark">
            <h5 class="mb-0">3. Trace Critical Path (Click Predecessor to Add)</h5>
          </div>
          <div class="card-body">
            <div id="predecessorList"></div>
            <!-- Gantt Chart Preview -->
            <div class="gantt-container">
              <canvas id="ganttChart"></canvas>
            </div>
          </div>
        </div>
      </div>

      <div class="col-lg-4">
        <div class="card shadow-sm mb-4">
          <div class="card-header bg-dark text-white">
            <h5 class="mb-0">Activity Log</h5>
          </div>
          <div class="card-body p-0">
            <pre id="log" class="log-container m-0 p-3"></pre>
          </div>
        </div>

        <div class="card shadow-sm">
          <div class="card-header bg-info text-white">
            <h5 class="mb-0">Critical Path (Final Output)</h5>
          </div>
          <div class="card-body">
            <table class="table table-sm table-hover final-path-table">
              <thead>
                <tr>
                  <th>Activity ID</th>
                  <th>Activity Name</th>
                  <th></th>
                </tr>
              </thead>
              <tbody id="criticalPathList"></tbody>
            </table>
            <button id="exportBtn" class="btn btn-success w-100" disabled>Export Critical Path as CSV</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    // Global data
    let activities = []; // Full parsed data
    let activityMap = {}; // Activity ID → object
    let criticalPath = []; // Final ordered list
    let ganttChart = null; // Chart.js instance
    let predSortField = null; // Sort field for predecessor table
    let predSortAsc = true; // Sort direction for predecessor table

    // DOM Elements
    const csvUpload = document.getElementById('csvUpload');
    const searchSection = document.getElementById('searchSection');
    const traceSection = document.getElementById('traceSection');
    const activitySearch = document.getElementById('activitySearch');
    const searchResults = document.getElementById('searchResults');
    const predecessorList = document.getElementById('predecessorList');
    const criticalPathList = document.getElementById('criticalPathList');
    const exportBtn = document.getElementById('exportBtn');
    const log = document.getElementById('log');
    const ganttCanvas = document.getElementById('ganttChart');
    const autoDetectBtn = document.getElementById('autoDetectBtn');

    // Log helper
    function addLog(message) {
      const timestamp = new Date().toLocaleTimeString();
      log.innerHTML += `[${timestamp}] ${message}\n`;
      log.scrollTop = log.scrollHeight;
    }

    // CSV Upload Handler
    csvUpload.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      addLog(`File selected: ${file.name}`);
      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        complete: (result) => {
          if (result.errors.length) {
            addLog(`Parse errors: ${result.errors.map(e => e.message).join('; ')}`);
            alert('CSV parsing failed. Check log.');
            return;
          }

          activities = result.data;
          activityMap = {};
          activities.forEach(act => {
            const id = act['Activity ID']?.trim();
            if (id) activityMap[id] = act;
          });

          addLog(`Successfully loaded ${activities.length} activities.`);
          searchSection.style.display = 'block';
          traceSection.style.display = 'none';
          criticalPath = [];
          updateCriticalPathUI();
          updateGanttChart();
          autoDetectBtn.disabled = false;
        },
        error: (err) => {
          addLog(`Parse error: ${err}`);
          alert('Failed to parse CSV.');
        }
      });
    });

    // Search Activities
    activitySearch.addEventListener('input', () => {
      const query = activitySearch.value.trim().toLowerCase();
      searchResults.innerHTML = '';

      if (!query) return;

      const matches = activities.filter(act => {
        const id = act['Activity ID']?.toLowerCase();
        const name = act['Activity Name']?.toLowerCase();
        return id?.includes(query) || name?.includes(query);
      }).slice(0, 10);

      if (matches.length === 0) {
        searchResults.innerHTML = '<div class="text-muted p-2">No activities found.</div>';
        return;
      }

      matches.forEach(act => {
        const div = document.createElement('div');
        div.className = 'activity-card p-2 border-bottom';
        div.innerHTML = `<strong>${act['Activity ID']}</strong> - ${act['Activity Name'] || 'N/A'}`;
        div.onclick = () => startCriticalPath(act);
        searchResults.appendChild(div);
      });
    });

    // Start tracing from selected activity
    function startCriticalPath(startAct) {
      addLog(`Starting critical path trace from: ${startAct['Activity ID']}`);
      criticalPath = [startAct];
      updateCriticalPathUI();
      showPredecessors(startAct);
      traceSection.style.display = 'block';
      activitySearch.value = '';
      searchResults.innerHTML = '';
      updateGanttChart();
    }

    // Show predecessors in sortable table
    function showPredecessors(currentAct) {
      predecessorList.innerHTML = '';
      const predIds = (currentAct.Predecessors || '')
        .split(/[,;]/)
        .map(s => s.trim())
        .filter(id => id && activityMap[id]);

      if (predIds.length === 0) {
        predecessorList.innerHTML = '<p class="text-muted">No predecessors found.</p>';
        addLog(`Activity ${currentAct['Activity ID']} has no predecessors.`);
        return;
      }

      addLog(`Found ${predIds.length} predecessor(s) for ${currentAct['Activity ID']}`);

      const table = document.createElement('table');
      table.className = 'table table-sm table-bordered predecessor-table';
      table.innerHTML = `
        <thead class="table-light">
          <tr>
            <th class="sortable" data-sort="Activity ID">Activity ID</th>
            <th class="sortable" data-sort="Activity Name">Name</th>
            <th class="sortable" data-sort="Start">Start</th>
            <th class="sortable" data-sort="Finish">Finish</th>
            <th class="sortable" data-sort="Total Float">Total Float</th>
            <th class="sortable" data-sort="Relationship Free Float">Rel. Float</th>
            <th class="sortable" data-sort="Primary Constraint">Constraint</th>
          </tr>
        </thead>
        <tbody id="predTableBody"></tbody>
      `;

      const tbody = table.querySelector('#predTableBody');
      const headers = table.querySelectorAll('.sortable');

      // Sort handler for predecessor table
      headers.forEach(th => {
        th.addEventListener('click', () => {
          const field = th.dataset.sort;
          if (predSortField === field) {
            predSortAsc = !predSortAsc;
          } else {
            predSortField = field;
            predSortAsc = true;
          }
          renderPredecessorRows(tbody, predIds);
        });
      });

      renderPredecessorRows(tbody, predIds);
      predecessorList.appendChild(table);
    }

    // Render sorted predecessor rows
    function renderPredecessorRows(tbody, predIds) {
      tbody.innerHTML = '';
      let sortedPreds = predIds.map(id => activityMap[id]);
      if (predSortField) {
        sortedPreds.sort((a, b) => {
          let valA = a[predSortField] || '';
          let valB = b[predSortField] || '';
          if (predSortField.includes('Date') || predSortField.includes('Start') || predSortField.includes('Finish')) {
            valA = new Date(valA) || 0;
            valB = new Date(valB) || 0;
          } else {
            valA = isNaN(valA) ? valA : Number(valA);
            valB = isNaN(valB) ? valB : Number(valB);
          }
          return (valA < valB ? -1 : 1) * (predSortAsc ? 1 : -1);
        });
      }

      sortedPreds.forEach(pred => {
        const row = document.createElement('tr');
        row.className = 'activity-card';
        row.style.cursor = 'pointer';
        row.innerHTML = `
          <td><strong>${pred['Activity ID']}</strong></td>
          <td>${pred['Activity Name'] || '—'}</td>
          <td>${pred['Start'] || '—'}</td>
          <td>${pred['Finish'] || '—'}</td>
          <td>${pred['Total Float'] || '—'}</td>
          <td>${pred['Relationship Free Float'] || '—'}</td>
          <td>${pred['Primary Constraint'] || '—'}</td>
        `;
        row.onclick = () => addToCriticalPath(pred);
        tbody.appendChild(row);
      });
    }

    // Add predecessor to critical path
    function addToCriticalPath(predAct) {
      if (criticalPath.some(a => a['Activity ID'] === predAct['Activity ID'])) {
        alert('Activity already in critical path.');
        return;
      }

      criticalPath.unshift(predAct);
      addLog(`Added predecessor: ${predAct['Activity ID']}`);
      updateCriticalPathUI();
      showPredecessors(predAct);
      updateGanttChart();
    }

    // Update final critical path UI (only ID + Name)
    function updateCriticalPathUI() {
      criticalPathList.innerHTML = '';
      criticalPath.forEach((act, i) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td><strong>${act['Activity ID']}</strong></td>
          <td>${act['Activity Name'] || 'N/A'}</td>
          <td><button class="btn btn-sm btn-outline-danger" onclick="removeFromPath(${i})">[cross]</button></td>
        `;
        criticalPathList.appendChild(tr);
      });
      exportBtn.disabled = criticalPath.length === 0;
    }

    // Remove from path
    window.removeFromPath = (index) => {
      const removed = criticalPath.splice(index, 1)[0];
      addLog(`Removed from path: ${removed['Activity ID']}`);
      updateCriticalPathUI();
      updateGanttChart();
      if (criticalPath.length > 0) {
        showPredecessors(criticalPath[0]);
      } else {
        predecessorList.innerHTML = '';
        traceSection.style.display = 'none';
      }
    };

    // Update Gantt Chart
    function updateGanttChart() {
      if (!criticalPath.length) {
        if (ganttChart) ganttChart.destroy();
        ganttChart = null;
        return;
      }

      const labels = criticalPath.map(a => `${a['Activity ID']}\n${a['Activity Name'] || ''}`);
      const startDates = criticalPath.map(a => a['Start'] ? new Date(a['Start']) : null);
      const endDates = criticalPath.map(a => a['Finish'] ? new Date(a['Finish']) : null);

      const datasets = [{
        label: 'Duration',
        data: criticalPath.map((a, i) => ({
          x: [startDates[i], endDates[i]],
          y: labels[i]
        })),
        backgroundColor: 'rgba(54, 162, 235, 0.8)',
        borderColor: 'rgba(54, 162, 235, 1)',
        borderWidth: 1
      }];

      const ctx = ganttCanvas.getContext('2d');
      if (ganttChart) ganttChart.destroy();

      ganttChart = new Chart(ctx, {
        type: 'bar',
        data: { labels, datasets },
        options: {
          indexAxis: 'y',
          scales: {
            x: { type: 'time', time: { unit: 'day' }, title: { display: true, text: 'Timeline' } },
            y: { title: { display: true, text: 'Activities' } }
          },
          plugins: {
            tooltip: { mode: 'index', intersect: false },
            legend: { display: false }
          },
          responsive: true,
          maintainAspectRatio: false
        }
      });
    }

    // Auto-Detect Critical Path (CPM)
    autoDetectBtn.addEventListener('click', () => {
      addLog('Running auto-detect critical path...');
      const zeroFloatActs = activities.filter(a => {
        const tf = parseFloat(a['Total Float'] || '');
        return !isNaN(tf) && tf === 0;
      });

      if (zeroFloatActs.length === 0) {
        addLog('No zero-float activities found.');
        alert('No critical path detected (no activities with Total Float = 0).');
        return;
      }

      // Build graph
      const graph = {};
      const indegree = {};
      zeroFloatActs.forEach(a => {
        const id = a['Activity ID'];
        graph[id] = (a.Successors || '').split(/[,;]/).map(s => s.trim()).filter(s => s && activityMap[s] && parseFloat(activityMap[s]['Total Float'] || '') === 0);
        indegree[id] = 0;
      });
      Object.values(graph).flat().forEach(s => indegree[s] = (indegree[s] || 0) + 1);

      // Find start nodes
      const starts = zeroFloatActs.filter(a => !indegree[a['Activity ID']]);
      if (starts.length === 0) {
        addLog('No valid start node in critical path.');
        return;
      }

      // Topological sort
      const path = [];
      const queue = [starts[0]['Activity ID']];
      const visited = new Set();

      while (queue.length) {
        const id = queue.shift();
        if (visited.has(id)) continue;
        visited.add(id);
        const act = activityMap[id];
        if (act) path.push(act);
        graph[id]?.forEach(succ => queue.push(succ));
      }

      if (path.length < 2) {
        addLog('Auto-detect found only isolated critical activities.');
        alert('Critical path too short or fragmented.');
        return;
      }

      criticalPath = path;
      addLog(`Auto-detected critical path with ${path.length} activities.`);
      updateCriticalPathUI();
      showPredecessors(criticalPath[0]);
      traceSection.style.display = 'block';
      updateGanttChart();
    });

    // Export Critical Path as CSV
    exportBtn.addEventListener('click', () => {
      if (criticalPath.length === 0) return;

      const headers = [
        'Project ID', 'Activity ID', 'Activity Name', 'Original Duration', 'At Completion Duration',
        'Remaining Duration', 'Early Start', 'Early Finish', 'Start', 'Finish', 'Late Start', 'Late Finish',
        'Predecessors', 'Successors', 'Activity Status', 'Total Float', 'Activity Type'
      ];

      const rows = criticalPath.map(act => headers.map(h => act[h] || ''));

      let csvContent = headers.join(',') + '\n' + rows.map(r => r.join(',')).join('\n');

      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `critical_path_${criticalPath[0]['Activity ID']}_to_${criticalPath[criticalPath.length-1]['Activity ID']}.csv`;
      a.click();
      URL.revokeObjectURL(url);

      addLog(`Exported critical path with ${criticalPath.length} activities.`);
    });
  </script>
</body>
</html>
