<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Critical Path Tracer</title>
  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"/>
  <!-- PapaParse for CSV parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <!-- Chart.js for Gantt -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <style>
    body { padding: 1.5rem; background-color: #f8f9fa; font-size: 0.9rem; }
    .log-container { max-height: 150px; overflow-y: auto; background: #f1f1f1; padding: 8px; border-radius: 5px; font-family: monospace; font-size: 0.8rem; }
    .activity-card { cursor: pointer; transition: 0.2s; }
    .activity-card:hover { background-color: #e9ecef; }
    .critical-path-list { min-height: 80px; }
    .search-results { max-height: 200px; overflow-y: auto; }
    .sortable { cursor: pointer; }
    .sortable::after { content: ' [sort]'; font-size: 0.75em; color: #666; }
    .gantt-container, .final-gantt-container { height: 250px; margin-top: 15px; }
    .predecessor-table th, .predecessor-table td { font-size: 0.8rem; padding: 4px; }
    .final-path-table th, .final-path-table td { font-size: 0.8rem; padding: 4px; }
    .card { margin-bottom: 1rem; }
    .card-body { padding: 0.75rem; }
    .card-header { padding: 0.5rem 0.75rem; font-size: 0.9rem; }
    .table-sm th, .table-sm td { padding: 0.25rem; }
    .btn-sm { padding: 0.15rem 0.3rem; font-size: 0.75rem; }
  </style>
</head>
<body>
  <div class="container-fluid">
    <h1 class="mb-3 text-primary">Critical Path Tracer</h1>
    <div class="row g-3">
      <!-- Left Column: Upload + Search + Tracing -->
      <div class="col-lg-7">
        <!-- Upload -->
        <div class="card shadow-sm">
          <div class="card-header bg-primary text-white">
            <h6 class="mb-0">1. Upload Schedule (CSV)</h6>
          </div>
          <div class="card-body">
            <input type="file" id="csvUpload" accept=".csv" class="form-control form-control-sm"/>
            <small class="text-muted">Headers: Activity ID, Start, Finish, Predecessors, Predecessor Details...</small>
          </div>
        </div>

        <!-- Search & Auto-Detect -->
        <div class="card shadow-sm" id="searchSection" style="display:none;">
          <div class="card-header bg-success text-white d-flex justify-content-between align-items-center">
            <h6 class="mb-0">2. Start Tracing</h6>
            <button id="autoDetectBtn" class="btn btn-outline-light btn-sm" disabled>Auto-Detect</button>
          </div>
          <div class="card-body">
            <input type="text" id="activitySearch" class="form-control form-control-sm mb-2" placeholder="Search ID or Name..."/>
            <div id="searchResults" class="search-results border p-2 bg-white small"></div>
          </div>
        </div>

        <!-- Tracing Area -->
        <div class="card shadow-sm" id="traceSection" style="display:none;">
          <div class="card-header bg-warning text-dark">
            <h6 class="mb-0">3. Click Predecessor to Add</h6>
          </div>
          <div class="card-body">
            <div id="predecessorList" class="mb-2"></div>
            <div class="gantt-container">
              <canvas id="ganttChart"></canvas>
            </div>
          </div>
        </div>
      </div>

      <!-- Right Column: Output + Final Gantt + Log -->
      <div class="col-lg-5">
        <!-- Final Output -->
        <div class="card shadow-sm">
          <div class="card-header bg-info text-white">
            <h6 class="mb-0">Final Critical Path</h6>
          </div>
          <div class="card-body">
            <table class="table table-sm table-hover final-path-table mb-2">
              <thead>
                <tr>
                  <th>ID</th>
                  <th>Name</th>
                  <th></th>
                </tr>
              </thead>
              <tbody id="criticalPathList"></tbody>
            </table>
            <button id="exportBtn" class="btn btn-success w-100 btn-sm" disabled>Export CSV</button>
          </div>
        </div>

        <!-- Final Gantt Chart - Separate Card -->
        <div class="card shadow-sm">
          <div class="card-header bg-danger text-white">
            <h6 class="mb-0">Final Gantt View (Gaps Visible)</h6>
          </div>
          <div class="card-body p-0">
            <div class="final-gantt-container">
              <canvas id="finalGanttChart"></canvas>
            </div>
          </div>
        </div>

        <!-- Log -->
        <div class="card shadow-sm">
          <div class="card-header bg-dark text-white">
            <h6 class="mb-0">Log</h6>
          </div>
          <div class="card-body p-0">
            <pre id="log" class="log-container m-0 p-2"></pre>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    // Global data
    let activities = []; // Full parsed data
    let activityMap = {}; // Activity ID → object
    let criticalPath = []; // Final ordered list
    let ganttChart = null; // Chart.js instance for tracing
    let finalGanttChart = null; // Chart.js instance for final output
    let predSortField = 'Activity Status'; // Default sort field
    let predSortAsc = true; // Default: ascending (Not Started → In Progress → Completed)

    // DOM Elements
    const csvUpload = document.getElementById('csvUpload');
    const searchSection = document.getElementById('searchSection');
    const traceSection = document.getElementById('traceSection');
    const activitySearch = document.getElementById('activitySearch');
    const searchResults = document.getElementById('searchResults');
    const predecessorList = document.getElementById('predecessorList');
    const criticalPathList = document.getElementById('criticalPathList');
    const exportBtn = document.getElementById('exportBtn');
    const log = document.getElementById('log');
    const ganttCanvas = document.getElementById('ganttChart');
    const finalGanttCanvas = document.getElementById('finalGanttChart');
    const autoDetectBtn = document.getElementById('autoDetectBtn');

    // Log helper
    function addLog(message) {
      const timestamp = new Date().toLocaleTimeString();
      log.innerHTML += `[${timestamp}] ${message}\n`;
      log.scrollTop = log.scrollHeight;
    }

    // Clean date string: remove exactly " A" (space + A) and "*" — preserve month "A" in dates like "Aug"
    function cleanDate(dateStr) {
      if (!dateStr) return '';
      return dateStr.toString().replace(/ A/g, '').replace(/\*/g, '').trim();
    }

    // CSV Upload Handler
    csvUpload.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      addLog(`File selected: ${file.name}`);
      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        complete: (result) => {
          if (result.errors.length) {
            addLog(`Parse errors: ${result.errors.map(e => e.message).join('; ')}`);
            alert('CSV parsing failed. Check log.');
            return;
          }

          activities = result.data.map(act => ({
            ...act,
            'Start': cleanDate(act['Start']),
            'Finish': cleanDate(act['Finish'])
          }));

          activityMap = {};
          activities.forEach(act => {
            const id = act['Activity ID']?.trim();
            if (id) activityMap[id] = act;
          });

          addLog(`Loaded ${activities.length} activities. Cleaned " A" and "*".`);
          searchSection.style.display = 'block';
          traceSection.style.display = 'none';
          criticalPath = [];
          updateCriticalPathUI();
          updateGanttChart();
          updateFinalGanttChart();
          autoDetectBtn.disabled = false;
        },
        error: (err) => {
          addLog(`Parse error: ${err}`);
          alert('Failed to parse CSV.');
        }
      });
    });

    // Search Activities
    activitySearch.addEventListener('input', () => {
      const query = activitySearch.value.trim().toLowerCase();
      searchResults.innerHTML = '';

      if (!query) return;

      const matches = activities.filter(act => {
        const id = act['Activity ID']?.toLowerCase();
        const name = act['Activity Name']?.toLowerCase();
        return id?.includes(query) || name?.includes(query);
      }).slice(0, 10);

      if (matches.length === 0) {
        searchResults.innerHTML = '<div class="text-muted p-1">No activities found.</div>';
        return;
      }

      matches.forEach(act => {
        const div = document.createElement('div');
        div.className = 'activity-card p-1 border-bottom small';
        div.innerHTML = `<strong>${act['Activity ID']}</strong> - ${act['Activity Name'] || 'N/A'}`;
        div.onclick = () => startCriticalPath(act);
        searchResults.appendChild(div);
      });
    });

    // Start tracing from selected activity
    function startCriticalPath(startAct) {
      addLog(`Starting trace from: ${startAct['Activity ID']}`);
      criticalPath = [startAct];
      updateCriticalPathUI();
      showPredecessors(startAct);
      traceSection.style.display = 'block';
      activitySearch.value = '';
      searchResults.innerHTML = '';
      updateGanttChart();
      updateFinalGanttChart();
    }

    // Show predecessors with custom status + finish sort
    function showPredecessors(currentAct) {
      predecessorList.innerHTML = '';
      const predDetails = (currentAct['Predecessor Details'] || '').split(';').map(s => s.trim()).filter(Boolean);
      const predMap = {};
      predDetails.forEach(d => {
        const [id, type] = d.split(':');
        if (id && type) predMap[id.trim()] = type.trim();
      });

      const predIds = (currentAct.Predecessors || '')
        .split(/[,;]/)
        .map(s => s.trim())
        .filter(id => id && activityMap[id]);

      if (predIds.length === 0) {
        predecessorList.innerHTML = '<p class="text-muted small">No predecessors.</p>';
        addLog(`Activity ${currentAct['Activity ID']} has no predecessors.`);
        return;
      }

      addLog(`Found ${predIds.length} predecessor(s).`);

      const table = document.createElement('table');
      table.className = 'table table-sm table-bordered predecessor-table';
      table.innerHTML = `
        <thead class="table-light">
          <tr>
            <th class="sortable" data-sort="Activity ID">ID</th>
            <th class="sortable" data-sort="Activity Name">Name</th>
            <th class="sortable" data-sort="Start">Start</th>
            <th class="sortable" data-sort="Finish">Finish</th>
            <th class="sortable" data-sort="Total Float">TF</th>
            <th class="sortable" data-sort="Relationship Free Float">RF</th>
            <th class="sortable" data-sort="Primary Constraint">Const</th>
            <th class="sortable" data-sort="Activity Status">Status</th>
            <th>Rel</th>
          </tr>
        </thead>
        <tbody id="predTableBody"></tbody>
      `;

      const tbody = table.querySelector('#predTableBody');
      const headers = table.querySelectorAll('.sortable');

      headers.forEach(th => {
        th.addEventListener('click', () => {
          const field = th.dataset.sort;
          if (predSortField === field) {
            predSortAsc = !predSortAsc;
          } else {
            predSortField = field;
            predSortAsc = true;
          }
          renderPredecessorRows(tbody, predIds, predMap);
        });
      });

      renderPredecessorRows(tbody, predIds, predMap);
      predecessorList.appendChild(table);
    }

    // Custom sort: Status (Not Started → In Progress → Completed), then Finish desc
    function renderPredecessorRows(tbody, predIds, predMap) {
      tbody.innerHTML = '';
      let sortedPreds = predIds.map(id => activityMap[id]);

      // Status priority: Not Started = 0, In Progress = 1, Completed = 2
      const statusOrder = { 'Not Started': 0, 'In Progress': 1, 'Completed': 2 };

      sortedPreds.sort((a, b) => {
        const statusA = a['Activity Status'] || '';
        const statusB = b['Activity Status'] || '';
        const orderA = statusOrder[statusA] ?? 3;
        const orderB = statusOrder[statusB] ?? 3;

        if (orderA !== orderB) {
          return orderA - orderB; // Not Started first
        }

        // Within same status, sort by Finish descending
        const finishA = new Date(a['Finish'] || '') || 0;
        const finishB = new Date(b['Finish'] || '') || 0;
        return finishB - finishA;
      });

      sortedPreds.forEach(pred => {
        const relType = predMap[pred['Activity ID']] || '—';
        const row = document.createElement('tr');
        row.className = 'activity-card';
        row.style.cursor = 'pointer';
        row.innerHTML = `
          <td><strong>${pred['Activity ID']}</strong></td>
          <td>${pred['Activity Name'] || '—'}</td>
          <td>${pred['Start'] || '—'}</td>
          <td>${pred['Finish'] || '—'}</td>
          <td>${pred['Total Float'] || '—'}</td>
          <td>${pred['Relationship Free Float'] || '—'}</td>
          <td>${pred['Primary Constraint'] || '—'}</td>
          <td>${pred['Activity Status'] || '—'}</td>
          <td>${relType}</td>
        `;
        row.onclick = () => addToCriticalPath(pred);
        tbody.appendChild(row);
      });
    }

    // Add predecessor to critical path
    function addToCriticalPath(predAct) {
      if (criticalPath.some(a => a['Activity ID'] === predAct['Activity ID'])) {
        alert('Already in path.');
        return;
      }

      criticalPath.unshift(predAct);
      addLog(`Added: ${predAct['Activity ID']}`);
      updateCriticalPathUI();
      showPredecessors(predAct); // Update to show new predecessor's predecessors
      updateGanttChart();
      updateFinalGanttChart();
    }

    // Update final critical path UI
    function updateCriticalPathUI() {
      criticalPathList.innerHTML = '';
      criticalPath.forEach((act, i) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td><strong>${act['Activity ID']}</strong></td>
          <td>${act['Activity Name'] || 'N/A'}</td>
          <td><button class="btn btn-sm btn-outline-danger" onclick="removeFromPath(${i})">[cross]</button></td>
        `;
        criticalPathList.appendChild(tr);
      });
      exportBtn.disabled = criticalPath.length === 0;
    }

    // Remove from path — now updates predecessor list to the new "front" activity
    window.removeFromPath = (index) => {
      const removed = criticalPath.splice(index, 1)[0];
      addLog(`Removed: ${removed['Activity ID']}`);
      updateCriticalPathUI();
      updateGanttChart();
      updateFinalGanttChart();

      // If path not empty, show predecessors of the *new first* activity
      if (criticalPath.length > 0) {
        showPredecessors(criticalPath[0]);
      } else {
        predecessorList.innerHTML = '';
        traceSection.style.display = 'none';
      }
    };

    // Update Gantt Chart (tracing)
    function updateGanttChart() {
      if (!criticalPath.length) {
        if (ganttChart) ganttChart.destroy();
        ganttChart = null;
        return;
      }

      const labels = criticalPath.map(a => `${a['Activity ID']}`);
      const startDates = criticalPath.map(a => a['Start'] ? new Date(a['Start']) : null);
      const endDates = criticalPath.map(a => a['Finish'] ? new Date(a['Finish']) : null);

      const datasets = [{
        label: 'Duration',
        data: criticalPath.map((a, i) => ({
          x: [startDates[i], endDates[i]],
          y: labels[i]
        })),
        backgroundColor: 'rgba(54, 162, 235, 0.8)',
        borderColor: 'rgba(54, 162, 235, 1)',
        borderWidth: 1
      }];

      const ctx = ganttCanvas.getContext('2d');
      if (ganttChart) ganttChart.destroy();

      ganttChart = new Chart(ctx, {
        type: 'bar',
        data: { labels, datasets },
        options: {
          indexAxis: 'y',
          scales: {
            x: { type: 'time', time: { unit: 'day' }, title: { display: true, text: 'Timeline' } },
            y: { title: { display: true, text: 'Activities' } }
          },
          plugins: {
            tooltip: { mode: 'index', intersect: false },
            legend: { display: false }
          },
          responsive: true,
          maintainAspectRatio: false
        }
      });
    }

    // Update Final Gantt Chart
    function updateFinalGanttChart() {
      if (!criticalPath.length) {
        if (finalGanttChart) finalGanttChart.destroy();
        finalGanttChart = null;
        return;
      }

      const labels = criticalPath.map(a => `${a['Activity ID']}`);
      const startDates = criticalPath.map(a => a['Start'] ? new Date(a['Start']) : null);
      const endDates = criticalPath.map(a => a['Finish'] ? new Date(a['Finish']) : null);

      const datasets = [{
        label: 'Duration',
        data: criticalPath.map((a, i) => ({
          x: [startDates[i], endDates[i]],
          y: labels[i]
        })),
        backgroundColor: 'rgba(220, 53, 69, 0.8)',
        borderColor: 'rgba(220, 53, 69, 1)',
        borderWidth: 1
      }];

      const ctx = finalGanttCanvas.getContext('2d');
      if (finalGanttChart) finalGanttChart.destroy();

      finalGanttChart = new Chart(ctx, {
        type: 'bar',
        data: { labels, datasets },
        options: {
          indexAxis: 'y',
          scales: {
            x: { type: 'time', time: { unit: 'day' }, title: { display: true, text: 'Final Path' } },
            y: { title: { display: true, text: 'Activities' } }
          },
          plugins: {
            tooltip: { mode: 'index', intersect: false },
            legend: { display: false }
          },
          responsive: true,
          maintainAspectRatio: false
        }
      });
    }

    // Auto-Detect Critical Path
    autoDetectBtn.addEventListener('click', () => {
      addLog('Running auto-detect...');
      const zeroFloatActs = activities.filter(a => {
        const tf = parseFloat(a['Total Float'] || '');
        return !isNaN(tf) && tf === 0;
      });

      if (zeroFloatActs.length === 0) {
        addLog('No zero-float activities.');
        alert('No critical path found.');
        return;
      }

      const graph = {};
      const indegree = {};
      zeroFloatActs.forEach(a => {
        const id = a['Activity ID'];
        graph[id] = (a.Successors || '').split(/[,;]/).map(s => s.trim()).filter(s => s && activityMap[s] && parseFloat(activityMap[s]['Total Float'] || '') === 0);
        indegree[id] = 0;
      });
      Object.values(graph).flat().forEach(s => indegree[s] = (indegree[s] || 0) + 1);

      const starts = zeroFloatActs.filter(a => !indegree[a['Activity ID']]);
      if (starts.length === 0) return;

      const path = [];
      const queue = [starts[0]['Activity ID']];
      const visited = new Set();

      while (queue.length) {
        const id = queue.shift();
        if (visited.has(id)) continue;
        visited.add(id);
        const act = activityMap[id];
        if (act) path.push(act);
        graph[id]?.forEach(succ => queue.push(succ));
      }

      if (path.length < 2) {
        alert('Critical path too short.');
        return;
      }

      criticalPath = path;
      addLog(`Auto-detected ${path.length} activities.`);
      updateCriticalPathUI();
      showPredecessors(criticalPath[0]);
      traceSection.style.display = 'block';
      updateGanttChart();
      updateFinalGanttChart();
    });

    // Export Critical Path as CSV
    exportBtn.addEventListener('click', () => {
      if (criticalPath.length === 0) return;

      const headers = [
        'Project ID', 'Activity ID', 'Activity Name', 'Original Duration', 'At Completion Duration',
        'Remaining Duration', 'Early Start', 'Early Finish', 'Start', 'Finish', 'Late Start', 'Late Finish',
        'Predecessors', 'Successors', 'Activity Status', 'Total Float', 'Activity Type'
      ];

      const rows = criticalPath.map(act => headers.map(h => act[h] || ''));

      let csvContent = headers.join(',') + '\n' + rows.map(r => r.join(',')).join('\n');

      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `critical_path_${criticalPath[0]['Activity ID']}_to_${criticalPath[criticalPath.length-1]['Activity ID']}.csv`;
      a.click();
      URL.revokeObjectURL(url);

      addLog(`Exported ${criticalPath.length} activities.`);
    });
  </script>
</body>
</html>
