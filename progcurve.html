<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>P6 S-Curve Dashboard (Live + Baseline, Forecast from Remaining Plan)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Bootstrap 5.3 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Chart.js v4 + moment adapter -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/moment@2.30.1/min/moment.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.1/dist/chartjs-adapter-moment.min.js"></script>
  <!-- Papa Parse -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    body { background: #f8f9fa; }
    .navbar-brand { font-weight: 600; letter-spacing: .3px; }
    #logArea { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: .9rem; }
    .metric-value { font-size: 1.6rem; font-weight: 700; }
    .metric-label { color: #6c757d; font-size: .9rem; }
    .chart-container { position: relative; height: 460px; }
  </style>
</head>
<body>
  <!-- Navbar -->
  <nav class="navbar navbar-expand-lg bg-white border-bottom">
    <div class="container-fluid">
      <a class="navbar-brand" href="#">P6 S-Curve Dashboard</a>
      <div class="d-flex gap-2">
        <button id="toggleLogBtn" class="btn btn-outline-secondary btn-sm">Show Status Log</button>
      </div>
    </div>
  </nav>

  <div class="container my-4">
    <!-- Uploads Row -->
    <div class="row g-3 align-items-end">
      <div class="col-12 col-lg-5">
        <label for="liveCsvInput" class="form-label">Live (Current) CSV — Actual & Forecast</label>
        <input type="file" class="form-control" id="liveCsvInput" accept=".csv" />
      </div>
      <div class="col-12 col-lg-5">
        <label for="baselineCsvInput" class="form-label">Baseline CSV — Early & Late</label>
        <input type="file" class="form-control" id="baselineCsvInput" accept=".csv" />
      </div>
      <div class="col-12 col-lg-2 d-grid">
        <button id="buildBtn" class="btn btn-primary">Build Chart</button>
      </div>
      <div class="col-12">
        <div id="alertArea"></div>
      </div>
    </div>

    <!-- Metrics Cards -->
    <div class="row row-cols-1 row-cols-md-2 row-cols-lg-4 g-3 my-3">
      <div class="col">
        <div class="card shadow-sm">
          <div class="card-body text-center">
            <div class="metric-value" id="metricPctComplete">—</div>
            <div class="metric-label">% Complete (Last Actual Day)</div>
          </div>
        </div>
      </div>
      <div class="col">
        <div class="card shadow-sm">
          <div class="card-body text-center">
            <div class="metric-value" id="metricDone">—</div>
            <div class="metric-label">Activities Completed (Actual Finish)</div>
          </div>
        </div>
      </div>
      <div class="col">
        <div class="card shadow-sm">
          <div class="card-body text-center">
            <div class="metric-value" id="metricTotal">—</div>
            <div class="metric-label">Total Activities (Task Dependent, Live)</div>
          </div>
        </div>
      </div>
      <div class="col">
        <div class="card shadow-sm">
          <div class="card-body text-center">
            <div class="metric-value" id="metricBaselineTotal">—</div>
            <div class="metric-label">Baseline Activities (Task Dependent)</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Chart -->
    <div class="card shadow-sm">
      <div class="card-body">
        <div class="chart-container">
          <canvas id="scurveChart"></canvas>
        </div>
      </div>
    </div>

    <!-- Status Log -->
    <div class="card shadow-sm mt-3 d-none" id="logCard">
      <div class="card-body">
        <label class="form-label">Status Log</label>
        <textarea id="logArea" class="form-control" rows="12" readonly></textarea>
      </div>
    </div>

    <!-- Help -->
    <details class="mt-3">
      <summary>CSV Expectations & Sample Columns</summary>
      <div class="mt-2">
        <p>Header-based CSV with columns like:</p>
        <pre><code>Activity ID,Activity Name,Activity Type,Start,Finish,Actual Start,Actual Finish,Early Start,Early Finish,Late Start,Late Finish
A1000,Example Task,Task Dependent,01/01/2025,01/15/2025,,01/14/2025 A,01/10/2025,01/14/2025,01/05/2025,01/20/2025*</code></pre>
        <ul>
          <li><strong>Markers removed:</strong> <code>" A"</code> and <code>"*"</code>.</li>
          <li>Accepted date formats: <code>MM/DD/YYYY</code>, <code>M/D/YY</code>, <code>DD-MMM-YYYY</code>, <code>YYYY-MM-DD</code>, with/without times.</li>
        </ul>
      </div>
    </details>
  </div>

  <script>
    // ======= UI: Logging & Alerts =======
    const logArea = document.getElementById('logArea');
    const logCard = document.getElementById('logCard');
    const toggleLogBtn = document.getElementById('toggleLogBtn');
    const alertArea = document.getElementById('alertArea');
    let chart; // Chart.js

    function ts() { return moment().format('YYYY-MM-DD HH:mm:ss'); }
    function log(msg) {
      logArea.value += `[${ts()}] ${msg}\n`;
      logArea.scrollTop = logArea.scrollHeight;
      console.log(msg);
    }
    function clearLog() { logArea.value = ''; }
    function showAlert(type, message) {
      alertArea.innerHTML = `
        <div class="alert alert-${type} alert-dismissible fade show" role="alert">
          ${message}
          <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        </div>`;
    }

    toggleLogBtn.addEventListener('click', () => {
      logCard.classList.toggle('d-none');
      toggleLogBtn.textContent = logCard.classList.contains('d-none') ? 'Show Status Log' : 'Hide Status Log';
    });

    // ======= Parsing Helpers =======
    const CANONICAL_FIELDS = [
      'Activity Type','Start','Finish',
      'Actual Start','Actual Finish',
      'Early Start','Early Finish',
      'Late Start','Late Finish'
    ];

    function normalizeHeader(h) {
      return String(h || '').toLowerCase().replace(/[\s_/-]+/g, '');
    }

    function buildHeaderMap(fields) {
      const map = {}; // canonical -> actual header
      const normFields = {};
      (fields || []).forEach(f => normFields[normalizeHeader(f)] = f);
      CANONICAL_FIELDS.forEach(c => {
        const norm = normalizeHeader(c);
        if (normFields[norm]) map[c] = normFields[norm];
      });
      return map;
    }

    const DATE_FORMATS = [
      'MM/DD/YYYY', 'M/D/YYYY', 'MM/DD/YY', 'M/D/YY',
      'YYYY-MM-DD',
      'DD-MMM-YYYY', 'D-MMM-YYYY', 'DD-MMM-YY', 'D-MMM-YY',
      'MM/DD/YYYY HH:mm', 'M/D/YYYY HH:mm',
      'DD-MMM-YYYY HH:mm', 'D-MMM-YYYY HH:mm'
    ];

    function cleanP6DateStr(s) {
      if (s === null || s === undefined) return '';
      let out = String(s);
      out = out.replace(/^"+|"+$/g, '');     // remove leading/trailing quotes
      out = out.replace(/\sA\b/gi, '');      // remove " A"
      out = out.replace(/\*/g, '');          // remove "*"
      out = out.replace(/\s+/g, ' ').trim(); // normalize spaces
      return out;
    }

    function parseP6Date(s) {
      const cleaned = cleanP6DateStr(s);
      if (!cleaned) return null;
      const m = moment(cleaned, DATE_FORMATS, true);
      if (!m.isValid()) return null;
      return m.startOf('day').toDate(); // normalize to start of local day
    }

    function isTaskDependent(v) {
      return String(v || '').trim().toLowerCase() === 'task dependent';
    }

    function cleanAndFilterRows(parsedRows, headerMap, label) {
      const out = [];
      let skippedType = 0, skippedDates = 0;
      for (const r of parsedRows) {
        const obj = {};
        obj['Activity Type'] = headerMap['Activity Type'] ? r[headerMap['Activity Type']] : undefined;
        ['Start','Finish','Actual Start','Actual Finish','Early Start','Early Finish','Late Start','Late Finish'].forEach(f => {
          obj[f] = headerMap[f] ? parseP6Date(r[headerMap[f]]) : null;
        });
        if (!isTaskDependent(obj['Activity Type'])) { skippedType++; continue; }
        if (!(obj['Start'] instanceof Date) || !(obj['Finish'] instanceof Date)) { skippedDates++; continue; }
        out.push(obj);
      }
      log(`${label}: rows after filter = ${out.length} (non-Task Dependent skipped: ${skippedType}, invalid Start/Finish skipped: ${skippedDates})`);
      return out;
    }

    function getSpan(rows) {
      let minDate = null, maxDate = null;
      const fields = ['Start','Finish','Actual Finish','Early Finish','Late Finish','Actual Start','Early Start','Late Start'];
      for (const r of rows) {
        for (const f of fields) {
          const d = r[f];
          if (d instanceof Date) {
            if (!minDate || d < minDate) minDate = d;
            if (!maxDate || d > maxDate) maxDate = d;
          }
        }
      }
      return { minDate, maxDate };
    }

    function buildDailyTimeline(minDate, maxDate) {
      const days = [];
      const cur = moment(minDate).startOf('day');
      const end = moment(maxDate).startOf('day');
      while (cur.isSameOrBefore(end)) {
        days.push(cur.toDate());
        cur.add(1, 'day');
      }
      return days;
    }

    function toISO(d) { return moment(d).format('YYYY-MM-DD'); }

    function computeCounts(timeline, finishDates) {
      const sorted = finishDates.filter(Boolean).sort((a,b)=>a-b);
      const counts = new Array(timeline.length).fill(0);
      let i = 0;
      for (let t = 0; t < timeline.length; t++) {
        const day = timeline[t];
        while (i < sorted.length && sorted[i] <= day) i++;
        counts[t] = i;
      }
      return counts;
    }

    function toPercent(counts, total) {
      return counts.map(c => {
        if (total === 0) return 0;
        const p = (c / total) * 100;
        return +Math.min(100, p).toFixed(2); // clamp to 100%
      });
    }

    function buildForecastFromRemaining(timeline, liveRows, actualCounts, lastActualDate, totalLive) {
      // Remaining tasks = those without an Actual Finish; use their Live 'Finish' dates
      const remainingFinishes = liveRows
        .filter(r => !(r['Actual Finish'] instanceof Date))
        .map(r => r['Finish'])
        .filter(d => d instanceof Date)
        .sort((a,b)=>a-b);

      const remainingCounts = computeCounts(timeline, remainingFinishes);
      log(`Forecast: remaining tasks = ${remainingFinishes.length} (using Live Finish dates).`);

      // Combine: before lastActualDate -> mirror Actual; on/after -> Actual + Remaining (capped at total)
      const outCounts = new Array(timeline.length).fill(0);
      const cut = lastActualDate ? moment(lastActualDate).startOf('day') : null;

      for (let i = 0; i < timeline.length; i++) {
        const day = timeline[i];
        if (cut && moment(day).isBefore(cut, 'day')) {
          outCounts[i] = actualCounts[i];
        } else {
          outCounts[i] = Math.min(totalLive, actualCounts[i] + remainingCounts[i]);
        }
      }
      return toPercent(outCounts, totalLive);
    }

    function updateMetrics({ lastActualPct, completedCount, totalLive, totalBaseline }) {
      document.getElementById('metricPctComplete').textContent = (lastActualPct ?? 0).toFixed(2) + '%';
      document.getElementById('metricDone').textContent = completedCount ?? 0;
      document.getElementById('metricTotal').textContent = totalLive ?? 0;
      document.getElementById('metricBaselineTotal').textContent = totalBaseline ?? 0;
    }

    function buildXYSeries(timeline, percents) {
      return timeline.map((d, i) => ({ x: d, y: percents[i] ?? 0 }));
    }

    function renderChart(timeline, datasets) {
      const ctx = document.getElementById('scurveChart').getContext('2d');
      if (chart) chart.destroy();

      const minX = timeline[0];
      const maxX = timeline[timeline.length - 1];

      chart = new Chart(ctx, {
        type: 'line',
        data: { datasets: [
          { label: 'Actual',   data: datasets.actual,   borderColor: '#0d6efd', backgroundColor: 'rgba(13,110,253,.08)', borderWidth: 2, tension: 0, pointRadius: 0, parsing: false },
          { label: 'Early',    data: datasets.early,    borderColor: '#198754', backgroundColor: 'rgba(25,135,84,.08)', borderWidth: 2, tension: 0, pointRadius: 0, parsing: false },
          { label: 'Late',     data: datasets.late,     borderColor: '#fd7e14', backgroundColor: 'rgba(253,126,20,.08)', borderWidth: 2, tension: 0, pointRadius: 0, parsing: false },
          { label: 'Forecast', data: datasets.forecast, borderColor: '#6c757d', backgroundColor: 'rgba(108,117,125,.08)', borderDash: [6, 4], borderWidth: 2, tension: 0, pointRadius: 0, parsing: false }
        ]},
        options: {
          responsive: true,
          maintainAspectRatio: false,
          spanGaps: true,
          scales: {
            x: {
              type: 'time',
              time: { unit: 'day', tooltipFormat: 'YYYY-MM-DD' },
              min: minX,
              max: maxX,
              bounds: 'ticks',
              grid: { display: false },
              ticks: { maxRotation: 0, autoSkip: true, autoSkipPadding: 16 }
            },
            y: {
              min: 0, max: 100,
              ticks: { callback: v => v + '%' },
              title: { display: true, text: 'Percent Complete' }
            }
          },
          plugins: {
            legend: { position: 'bottom' },
            tooltip: { callbacks: { label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y?.toFixed(2) ?? 0}%` } }
          },
          interaction: { mode: 'index', intersect: false }
        }
      });
    }

    // ======= State =======
    let liveParsed = null;     // { headerMap, rows: cleaned[] }
    let baselineParsed = null; // { headerMap, rows: cleaned[] }

    // ======= CSV Parsing =======
    function parseCsvFile(file, label, cb) {
      if (!file) { cb({ ok: false, error: 'No file selected.' }); return; }
      log(`${label}: CSV parse started…`);
      Papa.parse(file, {
        header: true,
        skipEmptyLines: 'greedy',
        worker: false, // local compatibility
        complete: (results) => {
          log(`${label}: CSV parse complete.`);
          if (results.errors && results.errors.length) {
            log(`${label}: Parser reported ${results.errors.length} error(s). First: ${results.errors[0].message}`);
          }
          const rowsRaw = results.data || [];
          if (!rowsRaw.length) {
            cb({ ok: false, error: `${label}: No data rows found.` });
            return;
          }
          const fields = results.meta?.fields || Object.keys(rowsRaw[0] || {});
          const headerMap = buildHeaderMap(fields);
          const required = ['Activity Type','Start','Finish'];
          const missing = required.filter(r => !headerMap[r]);
          if (missing.length) {
            cb({ ok: false, error: `${label}: Missing required column(s): ${missing.join(', ')}.` });
            log(`${label}: Detected headers: ${fields.join(', ')}`);
            return;
          }
          const cleaned = cleanAndFilterRows(rowsRaw, headerMap, label);
          cb({ ok: true, headerMap, rows: cleaned });
        },
        error: (err) => { cb({ ok: false, error: `${label}: CSV parsing failed: ${err?.message || err}` }); }
      });
    }

    // ======= Event Handlers =======
    document.getElementById('liveCsvInput').addEventListener('change', e => {
      clearLog(); alertArea.innerHTML = '';
      parseCsvFile(e.target.files[0], 'Live', (res) => {
        if (!res.ok) { showAlert('danger', res.error); return; }
        liveParsed = res;
        showAlert('info', 'Live CSV loaded. Load Baseline (optional) and click "Build Chart".');
      });
    });

    document.getElementById('baselineCsvInput').addEventListener('change', e => {
      parseCsvFile(e.target.files[0], 'Baseline', (res) => {
        if (!res.ok) { showAlert('warning', res.error); return; }
        baselineParsed = res;
        showAlert('info', 'Baseline CSV loaded. Click "Build Chart" to process.');
      });
    });

    document.getElementById('buildBtn').addEventListener('click', () => {
      alertArea.innerHTML = '';
      if (!liveParsed?.rows?.length) { showAlert('warning', 'Please load a Live (Current) CSV first.'); return; }

      const liveRows = liveParsed.rows;
      const baselineRows = baselineParsed?.rows || [];
      const totalLive = liveRows.length;
      const totalBaseline = baselineRows.length;

      // Determine overall timeline span using Live + Baseline
      const spanLive = getSpan(liveRows);
      const spanBase = getSpan(baselineRows);
      let minDate = spanLive.minDate, maxDate = spanLive.maxDate;
      if (spanBase.minDate && (!minDate || spanBase.minDate < minDate)) minDate = spanBase.minDate;
      if (spanBase.maxDate && (!maxDate || spanBase.maxDate > maxDate)) maxDate = spanBase.maxDate;

      if (!minDate || !maxDate) { showAlert('danger', 'Could not determine the overall date range. Check date formats.'); return; }
      log(`Timeline span: ${toISO(minDate)} → ${toISO(maxDate)}`);

      const timeline = buildDailyTimeline(minDate, maxDate);
      log(`Timeline days: ${timeline.length}`);

      // Finish arrays
      const liveActualFinishes = liveRows.map(r => r['Actual Finish']).filter(Boolean);
      let earlyFinishes = [];
      let lateFinishes  = [];

      if (baselineRows.length) {
        earlyFinishes = baselineRows.map(r => r['Early Finish']).filter(Boolean);
        lateFinishes  = baselineRows.map(r => r['Late Finish']).filter(Boolean);
        if (!earlyFinishes.length) log('Baseline: No Early Finish values found. Will fallback to Live.');
        if (!lateFinishes.length)  log('Baseline: No Late Finish values found. Will fallback to Live.');
      }

      // Fallback to Live Early/Late if Baseline lacks them
      if (!earlyFinishes.length) {
        const liveEarly = liveRows.map(r => r['Early Finish']).filter(Boolean);
        if (liveEarly.length) { earlyFinishes = liveEarly; showAlert('warning', 'Baseline Early Finish missing; using Live Early Finish.'); }
        else { showAlert('warning', 'No Early Finish values in Baseline or Live.'); }
      }
      if (!lateFinishes.length) {
        const liveLate = liveRows.map(r => r['Late Finish']).filter(Boolean);
        if (liveLate.length) { lateFinishes = liveLate; showAlert('warning', 'Baseline Late Finish missing; using Live Late Finish.'); }
        else { showAlert('warning', 'No Late Finish values in Baseline or Live.'); }
      }

      // Compute counts (step-like)
      const actualCounts = computeCounts(timeline, liveActualFinishes);
      const earlyCounts  = computeCounts(timeline, earlyFinishes);
      const lateCounts   = computeCounts(timeline, lateFinishes);

      const actualPerc = toPercent(actualCounts, totalLive);
      const earlyPerc  = toPercent(earlyCounts,  totalLive);
      const latePerc   = toPercent(lateCounts,   totalLive);

      // Forecast based on remaining tasks' planned finishes (Live 'Finish'), mirroring Actual before last actual date
      const lastActualDate = liveActualFinishes.filter(Boolean).sort((a,b)=>a-b).slice(-1)[0] || null;
      if (lastActualDate) log(`Last Actual Finish (Live): ${toISO(lastActualDate)}`); else log('No Actual Finish dates in Live. Forecast will be fully planned.');

      const forecastPerc = buildForecastFromRemaining(timeline, liveRows, actualCounts, lastActualDate, totalLive);

      // Metrics
      let lastActualPct = 0;
      if (lastActualDate) {
        const labelsISO = timeline.map(toISO);
        const idx = labelsISO.findIndex(d => d === toISO(lastActualDate));
        lastActualPct = idx >= 0 ? actualPerc[idx] : actualPerc[actualPerc.length - 1];
      }

      updateMetrics({ lastActualPct, completedCount: liveActualFinishes.length, totalLive, totalBaseline });

      // Build XY series and render
      log('Rendering chart…');
      renderChart(timeline, {
        actual:   buildXYSeries(timeline, actualPerc),
        early:    buildXYSeries(timeline, earlyPerc),
        late:     buildXYSeries(timeline, latePerc),
        forecast: buildXYSeries(timeline, forecastPerc)
      });
      log('Done.');
    });
  </script>

  <!-- Bootstrap JS (for alerts) -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
