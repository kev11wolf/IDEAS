<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P6 Schedule Health Check Suite</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fa;
            margin: 0;
            padding: 20px;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 30px;
        }
        h1 {
            text-align: center;
            color: #495057;
            margin-bottom: 30px;
        }
        h2 {
            color: #495057;
            margin-top: 0;
        }
        .upload-section {
            text-align: center;
            margin-bottom: 30px;
        }
        input[type="file"], input[type="text"], button {
            padding: 10px;
            margin: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #0056b3;
        }
        .results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 20px;
            border-left: 4px solid #007bff;
            margin-bottom: 20px;
        }
        .card.fail {
            border-left-color: #dc3545;
        }
        .card.pass {
            border-left-color: #28a745;
        }
        .card h3 {
            margin-top: 0;
            color: #495057;
        }
        .score {
            font-size: 24px;
            font-weight: bold;
            margin: 10px 0;
        }
        .pass .score { color: #28a745; }
        .fail .score { color: #dc3545; }
        .description, .suggestions {
            font-size: 14px;
            line-height: 1.5;
            color: #6c757d;
        }
        .issues {
            background: #f8f9fa;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            font-size: 12px;
        }
        .issues ul {
            margin: 5px 0;
            padding-left: 20px;
        }
        .loading {
            text-align: center;
            color: #6c757d;
        }
        .stats {
            background: #e9ecef;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .stat-item {
            display: inline-block;
            margin: 0 20px;
            font-weight: bold;
        }
        #exportButton {
            display: none; /* Hidden until results are displayed */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>P6 Schedule Health Check Suite</h1>
        
        <!-- About this Tool Card -->
        <div class="card">
            <h2>About this Tool</h2>
            <p>
                This tool analyzes a Primavera P6 schedule exported to a CSV file.
                It applies several metrics – commonly known as “14-Point” or “Schedule Health” checks – 
                to evaluate overall schedule quality and identify potential flaws.
            </p>
            <p><strong>Sample Columns Expected:</strong></p>
            <ul>
                <li><code>Activity ID</code>, <code>Activity Name</code></li>
                <li><code>Original Duration</code>, <code>Remaining Duration</code>, <code>Total Float</code></li>
                <li><code>Predecessors</code>, <code>Successors</code></li>
                <li><code>Constraint Type</code>, <code>Actual Start</code>, <code>Actual Finish</code></li>
                <li><code>Baseline Finish</code>, <code>Primary Resource</code>/<code>Resource Names</code></li>
            </ul>
            <p><strong>Metrics and Checks Performed:</strong></p>
            <ul>
                <li>Logic (Open Ends), Negative Lags, Lags, Long Lags</li>
                <li>Relationship Types (FS), Hard/Soft Constraints</li>
                <li>Large Float, Negative Float, Large Durations</li>
                <li>Invalid Progress Dates, Resource/Cost Loading</li>
                <li>Late Activities, Baseline Execution Index (BEI)</li>
            </ul>
            <p>
                Every check calculates a percentage of potential issues in the schedule and compares
                that result to a typical benchmark or threshold. A result below (or above, where
                applicable) the threshold is considered a pass, otherwise a fail. The Overall Health
                Score sums up how many checks passed.
            </p>
        </div>
        <!-- End About this Tool Card -->

        <div class="upload-section">
            <input type="file" id="csvFile" accept=".csv">
            <input type="text" id="dataDate" placeholder="Data Date (mm/dd/yyyy)" style="width: 200px;">
            <br>
            <button onclick="analyzeSchedule()">Analyze Schedule</button>
            <button id="exportButton" onclick="exportResults()">Export Results</button>
        </div>
        <div id="loading" class="loading" style="display: none;">Analyzing schedule...</div>
        <div id="results" class="results" style="display: none;"></div>
    </div>

    <script>
        /* A global reference so we can export after analysis. */
        let globalChecks = [];

        // Simple CSV Parser (handles basic quoted fields)
        function parseCSV(csvText) {
            const lines = csvText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            if (lines.length === 0) return [];
            const headers = parseLine(lines[0]);
            return lines.slice(1).map(line => {
                const values = parseLine(line);
                const obj = {};
                headers.forEach((header, i) => {
                    obj[header] = values[i] || '';
                });
                return obj;
            });
        }

        function parseLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim().replace(/^"|"$/g, ''));
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim().replace(/^"|"$/g, ''));
            return result;
        }

        // Parse date string mm/dd/yyyy or mm/dd/yy
        function parseP6Date(dateStr) {
            if (!dateStr) return null;
            const parts = dateStr.split('/');
            if (parts.length !== 3) return null;
            let year = parseInt(parts[2]);
            if (year < 100) year += 2000;
            return new Date(year, parseInt(parts[0]) - 1, parseInt(parts[1]));
        }

        // Parse relationship string e.g. "ACT1:FS:5d,ACT2:SS:-2h"
        function parseRelationships(relStr) {
            if (!relStr) return [];
            return relStr.split(',').map(rel => {
                const parts = rel.split(':');
                if (parts.length < 3) return null;
                const id = parts[0].trim();
                const type = parts[1].trim();
                const lagStr = parts[2].trim();
                let lag = 0;
                const lagMatch = lagStr.match(/([+-]?\d+(?:\.\d+)?)([dh]?)/i);
                if (lagMatch) {
                    lag = parseFloat(lagMatch[1]);
                    const unit = lagMatch[2].toLowerCase();
                    if (unit === 'd') lag *= 8; // Assume 8-hour days
                }
                return { id, type, lag };
            }).filter(rel => rel !== null);
        }

        // Get activity status
        function getStatus(activity) {
            const pct = parseFloat(activity['Activity % Complete'] || 0);
            if (pct === 100) return 'Completed';
            if (pct > 0) return 'In Progress';
            return 'Not Started';
        }

        // Is exclusion? (Milestone, WBS Summary, LOE - approximate)
        function isExcluded(activity, checkType) {
            const duration = parseFloat(activity['Remaining Duration'] || activity['Original Duration'] || 0);
            const name = (activity['Activity Name'] || '').toLowerCase();
            const type = activity['Activity Type'] || '';
            const isMilestone = duration === 0;
            const isSummary = name.includes('summary') || type.includes('wbs');
            const isLOE = type.includes('effort');
            return isMilestone || isSummary || isLOE;
        }

        // Perform all 14 checks
        function performChecks(activities, dataDate) {
            const totalActs = activities.length;
            const checks = [];
            const threshold = 352; // hours, ~44 days
            const targetPass = 5; // % threshold for pass/fail

            // 1. Logic (Open Ends)
            let openEnds = 0;
            let openEndActivities = [];
            activities.forEach(act => {
                if (isExcluded(act, 'logic')) return;
                const preds = parseRelationships(act['Predecessors'] || '').length;
                const succs = parseRelationships(act['Successors'] || '').length;
                if (preds === 0 || succs === 0) {
                    openEnds++;
                    openEndActivities.push({
                        id: act['Activity ID'], 
                        name: act['Activity Name']
                    });
                }
            });
            const logicPct = (openEnds / totalActs) * 100;
            checks.push({
                name: 'Logic (Open Ends)',
                score: logicPct.toFixed(2),
                pass: logicPct < targetPass,
                description: 'Percentage of activities with no predecessor or no successor.',
                suggestions: 'Connect dangling activities to ensure complete logic ties.',
                issues: openEndActivities.slice(0, 50) // Show up to 50 here, can adjust as needed
            });

            // 2. Negative Lags
            let negLags = 0;
            let totalRels = 0;
            let negLagActivities = [];
            activities.forEach(act => {
                if (getStatus(act) === 'Completed') return;
                const preds = parseRelationships(act['Predecessors'] || '');
                preds.forEach(rel => {
                    if (rel.lag < 0) {
                        negLags++;
                        negLagActivities.push({
                            id: act['Activity ID'],
                            name: act['Activity Name']
                        });
                    }
                    totalRels++;
                });
            });
            const negLagPct = totalRels > 0 ? (negLags / totalRels) * 100 : 0;
            checks.push({
                name: 'Negative Lags',
                score: negLagPct.toFixed(2),
                pass: negLagPct < targetPass,
                description: 'Percentage of relationships with negative lags.',
                suggestions: 'Avoid negative lags; adjust logic instead.',
                issues: negLagActivities.slice(0, 50)
            });

            // 3. Lags
            let lags = 0;
            totalRels = 0;
            let lagActivities = [];
            activities.forEach(act => {
                if (getStatus(act) === 'Completed') return;
                const preds = parseRelationships(act['Predecessors'] || '');
                preds.forEach(rel => { 
                    if (rel.lag > 0) {
                        lags++;
                        lagActivities.push({
                            id: act['Activity ID'],
                            name: act['Activity Name']
                        });
                    }
                    totalRels++;
                });
            });
            const lagPct = totalRels > 0 ? (lags / totalRels) * 100 : 0;
            checks.push({
                name: 'Lags',
                score: lagPct.toFixed(2),
                pass: lagPct < 25, // Typical target <25%
                description: 'Percentage of relationships with positive lags.',
                suggestions: 'Minimize lags where possible; use separate activities for waits.',
                issues: lagActivities.slice(0, 50)
            });

            // 4. Long Lags
            let longLags = 0;
            let longLagActivities = [];
            activities.forEach(act => {
                if (getStatus(act) === 'Completed') return;
                const preds = parseRelationships(act['Predecessors'] || '');
                preds.forEach(rel => { 
                    if (rel.lag > threshold) {
                        longLags++;
                        longLagActivities.push({
                            id: act['Activity ID'],
                            name: act['Activity Name']
                        });
                    }
                });
            });
            const longLagPct = totalRels > 0 ? (longLags / totalRels) * 100 : 0;
            checks.push({
                name: 'Long Lags',
                score: longLagPct.toFixed(2),
                pass: longLagPct < targetPass,
                description: 'Percentage of relationships with lags > 44 days.',
                suggestions: 'Break down long lags into activities.',
                issues: longLagActivities.slice(0, 50)
            });

            // 5. Relationship Types (FS >90%)
            let fsCount = 0;
            let totalTypes = 0;
            let nonFSActivities = [];
            activities.forEach(act => {
                if (getStatus(act) === 'Completed') return;
                const preds = parseRelationships(act['Predecessors'] || '');
                preds.forEach(rel => {
                    if (rel.type === 'FS') fsCount++;
                    else {
                        nonFSActivities.push({
                            id: act['Activity ID'],
                            name: act['Activity Name']
                        });
                    }
                    totalTypes++;
                });
            });
            const fsPct = totalTypes > 0 ? (fsCount / totalTypes) * 100 : 0;
            checks.push({
                name: 'Relationship Types (FS)',
                score: fsPct.toFixed(2),
                pass: fsPct > 90,
                description: 'Percentage of Finish-to-Start relationships.',
                suggestions: 'Prefer FS relationships; review others.',
                issues: nonFSActivities.slice(0, 50)
            });

            // 6. Hard Constraints
            let hardConst = 0;
            let hardConstActivities = [];
            activities.forEach(act => {
                if (isExcluded(act, 'constraints')) return;
                const constType = act['Constraint Type'] || '';
                if (constType.includes('Mandatory')) {
                    hardConst++;
                    hardConstActivities.push({
                        id: act['Activity ID'],
                        name: act['Activity Name']
                    });
                }
            });
            const hardPct = (hardConst / totalActs) * 100;
            checks.push({
                name: 'Hard Constraints',
                score: hardPct.toFixed(2),
                pass: hardPct < targetPass,
                description: 'Percentage of activities with hard constraints.',
                suggestions: 'Remove hard constraints; let logic drive dates.',
                issues: hardConstActivities.slice(0, 50)
            });

            // 7. Soft Constraints
            let softConst = 0;
            let softConstActivities = [];
            activities.forEach(act => {
                if (isExcluded(act, 'constraints')) return;
                const constType = act['Constraint Type'] || '';
                if (constType && !constType.includes('Mandatory') && !constType.includes('None')) {
                    softConst++;
                    softConstActivities.push({
                        id: act['Activity ID'],
                        name: act['Activity Name']
                    });
                }
            });
            const softPct = (softConst / totalActs) * 100;
            checks.push({
                name: 'Soft Constraints',
                score: softPct.toFixed(2),
                pass: softPct < 25, // Typical <25%
                description: 'Percentage of activities with soft constraints.',
                suggestions: 'Minimize constraints; use as few as possible.',
                issues: softConstActivities.slice(0, 50)
            });

            // 8. Large Float
            let largeFloat = 0;
            let largeFloatActivities = [];
            activities.forEach(act => {
                if (isExcluded(act, 'float')) return;
                const tf = parseFloat(act['Total Float'] || 0);
                if (tf > threshold) {
                    largeFloat++;
                    largeFloatActivities.push({
                        id: act['Activity ID'],
                        name: act['Activity Name']
                    });
                }
            });
            const largeFloatPct = (largeFloat / totalActs) * 100;
            checks.push({
                name: 'Large Float',
                score: largeFloatPct.toFixed(2),
                pass: largeFloatPct < targetPass,
                description: 'Percentage of activities with total float > 44 days.',
                suggestions: 'Add relationships to reduce excessive float.',
                issues: largeFloatActivities.slice(0, 50)
            });

            // 9. Negative Float
            let negFloat = 0;
            let negFloatActivities = [];
            activities.forEach(act => {
                if (isExcluded(act, 'float')) return;
                const tf = parseFloat(act['Total Float'] || 0);
                if (tf < 0) {
                    negFloat++;
                    negFloatActivities.push({
                        id: act['Activity ID'],
                        name: act['Activity Name']
                    });
                }
            });
            const negFloatPct = (negFloat / totalActs) * 100;
            checks.push({
                name: 'Negative Float',
                score: negFloatPct.toFixed(2),
                pass: negFloatPct === 0,
                description: 'Percentage of activities with negative total float.',
                suggestions: 'Resolve constraints or logic causing negative float.',
                issues: negFloatActivities.slice(0, 50)
            });

            // 10. Large Durations
            let largeDur = 0;
            let largeDurActivities = [];
            activities.forEach(act => {
                if (isExcluded(act, 'duration')) return;
                const dur = parseFloat(act['Remaining Duration'] || 0);
                if (dur > threshold) {
                    largeDur++;
                    largeDurActivities.push({
                        id: act['Activity ID'],
                        name: act['Activity Name']
                    });
                }
            });
            const largeDurPct = (largeDur / totalActs) * 100;
            checks.push({
                name: 'Large Durations',
                score: largeDurPct.toFixed(2),
                pass: largeDurPct < targetPass,
                description: 'Percentage of activities with remaining duration > 44 days.',
                suggestions: 'Subdivide long-duration activities.',
                issues: largeDurActivities.slice(0, 50)
            });

            // 11. Invalid Progress Dates (simplified, requires dataDate)
            let invalidDates = 0;
            let invalidDateActivities = [];
            if (dataDate) {
                activities.forEach(act => {
                    if (isExcluded(act, 'dates')) return;
                    const status = getStatus(act);
                    const actualStart = parseP6Date(act['Actual Start']);
                    const actualFinish = parseP6Date(act['Actual Finish']);
                    // Simplified checks:
                    if (status === 'Not Started' && actualStart && actualStart < dataDate) {
                        invalidDates++;
                        invalidDateActivities.push({
                            id: act['Activity ID'],
                            name: act['Activity Name']
                        });
                    } else if ((status === 'In Progress' || status === 'Completed') && actualFinish && actualFinish < dataDate) {
                        invalidDates++;
                        invalidDateActivities.push({
                            id: act['Activity ID'],
                            name: act['Activity Name']
                        });
                    }
                });
            }
            const invalidPct = dataDate ? (invalidDates / totalActs) * 100 : 0;
            checks.push({
                name: 'Invalid Progress Dates',
                score: invalidPct.toFixed(2),
                pass: invalidPct === 0,
                description: 'Percentage of activities with invalid dates relative to data date.',
                suggestions: 'Correct actual dates to align with data date.',
                issues: invalidDateActivities.slice(0, 50)
            });

            // 12. Resource / Cost
            let noResource = 0;
            let noResourceActivities = [];
            activities.forEach(act => {
                if (isExcluded(act, 'resource')) return;
                const resources = act['Primary Resource'] || act['Resource Names'] || '';
                if (!resources.trim()) {
                    noResource++;
                    noResourceActivities.push({
                        id: act['Activity ID'],
                        name: act['Activity Name']
                    });
                }
            });
            const noResPct = (noResource / totalActs) * 100;
            checks.push({
                name: 'Resource / Cost Loading',
                score: noResPct.toFixed(2),
                pass: noResPct < 25, // Allow some non-resource activities
                description: 'Percentage of activities without resources assigned.',
                suggestions: 'Assign resources to all executable activities.',
                issues: noResourceActivities.slice(0, 50)
            });

            // 13. Late Activities
            let lateActs = 0;
            let lateActivities = [];
            activities.forEach(act => {
                if (isExcluded(act, 'late')) return;
                const blFinish = parseP6Date(act['Baseline Finish']);
                const ef = parseP6Date(act['Early Finish']);
                if (blFinish && ef && ef > blFinish) {
                    lateActs++;
                    lateActivities.push({
                        id: act['Activity ID'],
                        name: act['Activity Name']
                    });
                }
            });
            const latePct = (lateActs / totalActs) * 100;
            checks.push({
                name: 'Late Activities',
                score: latePct.toFixed(2),
                pass: latePct < 10, // Arbitrary
                description: 'Percentage of activities behind baseline.',
                suggestions: 'Investigate and recover delays.',
                issues: lateActivities.slice(0, 50)
            });

            // 14. BEI - Baseline Execution Index
            let completed = 0;
            let shouldComplete = 0;
            // We won't capture "issues" in the same sense, but we could note them if needed...
            if (dataDate) {
                activities.forEach(act => {
                    if (isExcluded(act, 'bei')) return;
                    const status = getStatus(act);
                    if (status === 'Completed') completed++;
                    const blFinish = parseP6Date(act['Baseline Finish']);
                    if (blFinish && blFinish <= dataDate) shouldComplete++;
                });
            }
            const bei = shouldComplete > 0 ? (completed / shouldComplete) : 1;
            const beiPct = bei * 100;
            checks.push({
                name: 'BEI (Baseline Execution Index)',
                score: beiPct.toFixed(2),
                pass: beiPct > 95,
                description: 'Ratio of completed to baseline-scheduled completions by data date.',
                suggestions: 'If low, accelerate execution.',
                issues: [] // This check doesn't store specific activity-level issues
            });

            // Overall stats
            const overallPass = checks.filter(c => c.pass).length / checks.length * 100;
            checks.unshift({
                name: 'Overall Health Score',
                score: overallPass.toFixed(2) + '%',
                pass: overallPass > 80,
                description: 'Percentage of checks passing.',
                suggestions: overallPass < 80 
                    ? 'Address failing checks to improve schedule quality.' 
                    : 'Schedule is generally healthy.',
                issues: []
            });

            return checks;
        }

        // Display results
        function displayResults(checks) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '';
            checks.forEach(check => {
                const card = document.createElement('div');
                card.className = `card ${check.pass ? 'pass' : 'fail'}`;
                
                // Build the list of issues
                let issueList = '';
                if (check.issues.length > 0) {
                    issueList = `
                        <div class="issues">
                            <strong>Issues (${check.issues.length} found; showing up to 50):</strong>
                            <ul>
                                ${check.issues.map(issue => `<li>${issue.id} - ${issue.name}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                } else {
                    // If no issues for this check
                    issueList = '<div class="issues">No issues found.</div>';
                }

                card.innerHTML = `
                    <h3>${check.name}</h3>
                    <div class="score">${check.score}</div>
                    <div class="description">${check.description}</div>
                    <div class="suggestions">${check.suggestions}</div>
                    ${issueList}
                `;
                resultsDiv.appendChild(card);
            });
            resultsDiv.style.display = 'grid';
            
            // Show the "Export Results" button
            document.getElementById('exportButton').style.display = 'inline-block';
        }

        // Main analyze function
        function analyzeSchedule() {
            const fileInput = document.getElementById('csvFile');
            const dataDateInput = document.getElementById('dataDate');
            if (!fileInput.files[0]) {
                alert('Please select a CSV file.');
                return;
            }
            if (!dataDateInput.value) {
                alert('Please enter the Data Date (mm/dd/yyyy).');
                return;
            }
            const dataDate = parseP6Date(dataDateInput.value);
            if (!dataDate) {
                alert('Invalid Data Date format. Use mm/dd/yyyy.');
                return;
            }

            document.getElementById('loading').style.display = 'block';
            document.getElementById('results').style.display = 'none';

            const file = fileInput.files[0];
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvData = parseCSV(e.target.result);
                    if (csvData.length < 1) throw new Error('No data in CSV');
                    const checks = performChecks(csvData, dataDate);

                    // Store globally so we can export as needed
                    globalChecks = checks;

                    displayResults(checks);
                } catch (err) {
                    alert('Error parsing CSV: ' + err.message + '\nEnsure it has standard P6 columns like Activity ID, Total Float, etc.');
                } finally {
                    document.getElementById('loading').style.display = 'none';
                }
            };
            reader.readAsText(file);
        }

        // Export results to a .txt file
        function exportResults() {
            if (!globalChecks || globalChecks.length === 0) {
                alert("No results to export. Please analyze a schedule first.");
                return;
            }

            let content = "P6 Schedule Health Check Results\n\n";
            globalChecks.forEach(check => {
                content += `CHECK: ${check.name}\n`;
                content += `Score: ${check.score}\n`;
                content += `Description: ${check.description}\n`;
                content += `Suggestions: ${check.suggestions}\n`;

                if (check.issues && check.issues.length > 0) {
                    content += `Issues (${check.issues.length} total, listing up to 50):\n`;
                    check.issues.forEach(issue => {
                        content += `   ${issue.id} - ${issue.name}\n`;
                    });
                } else {
                    content += "No issues found.\n";
                }
                content += "\n----------------------------------------------------------\n\n";
            });

            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = "P6_Health_Check_Results.txt";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
