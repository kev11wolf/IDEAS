<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Org Chart with Auto-Save Editable Fields and Click-Off Unselect</title>
  <!-- Load Roboto font from Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet" />
  <!-- Libraries for Export to PDF: html2canvas + jsPDF -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <style>
    /* Use Roboto font for everything */
    body, button, input, .org-node {
      font-family: 'Roboto', sans-serif;
    }
    body {
      margin: 0;
      padding: 0;
      background-color: #f3f4f6;
      color: #333;
    }

    /* Container for the top controls, multiple rows */
    #controls {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      padding: 10px;
      background: #ffffff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      position: sticky;
      top: 0;
      z-index: 9999;
    }
    .control-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 8px;
      align-items: center;
    }
    #controls button,
    #controls input[type="color"],
    #controls input[type="range"],
    #controls input[type="text"] {
      padding: 6px 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: #eee;
      cursor: pointer;
      transition: background 0.2s;
    }
    #controls button:hover {
      background: #ddd;
    }
    #controls input[type="color"] {
      height: 34px;
      width: 34px;
      padding: 0;
      border: 1px solid #ccc;
    }
    .opacity-range,
    #containerWidthRange,
    #containerHeightRange {
      width: 80px;
    }
    /* Disabled inputs style */
    input[disabled], button[disabled] {
      cursor: not-allowed;
      opacity: 0.6;
    }

    /* The org chart container */
    #orgChartContainer {
      width: 2000px;       /* default large width */
      height: 2000px;      /* default large height */
      position: relative;
      border-top: 1px solid #e0e0e0;
      overflow: auto;      /* scroll if needed */
      background: #fafafa;
      transform-origin: top left; /* for zooming */
      transform: scale(1);       /* default scale */
    }

    /* Basic styling for an org node */
    .org-node {
      position: absolute;
      min-height: 40px;
      min-width: 110px;
      padding: 8px;
      font-size: 14px;
      border: 1px solid #333;
      border-radius: 4px;
      text-align: center;
      cursor: move;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.2);
      user-select: none;
      z-index: 1;
      white-space: normal;
      word-wrap: break-word;
      resize: none;
      overflow: hidden;
    }
    .org-node .name {
      font-weight: bold;
      margin-bottom: 4px;
    }
    .org-node .title {
      font-size: 12px;
      color: #666;
    }

    /* Invisible resize corner in the bottom-right */
    .resize-handle {
      position: absolute;
      bottom: 0;
      right: 0;
      width: 15px;
      height: 15px;
      background: transparent;
      cursor: se-resize;
      user-select: none;
    }

    /* Connector line segments behind nodes */
    .connector-segment {
      position: absolute;
      background-color: #333;
      z-index: 0;
    }

    /* Highlight selected nodes with a blue outline & bold text */
    .org-node.selected {
      outline: 2px solid blue;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <!-- Controls at the top -->
  <div id="controls">
    <!-- (1) Row for Node & Chart Management -->
    <div class="control-row">
      <button id="newNodeBtn">New Node</button>
      <button id="autoOrganizeBtn">Auto-Organize</button>
      <button id="autoSizeBtn">Auto Size All Nodes</button>
      <button id="exportPDFBtn">Export to PDF</button>
    </div>

    <!-- (2) Row for Zoom & Container Size Sliders -->
    <div class="control-row">
      <button id="zoomOutBtn">Zoom Out</button>
      <button id="zoomInBtn">Zoom In</button>
      <label for="containerWidthRange">Width:</label>
      <input type="range" id="containerWidthRange" min="1000" max="5000" value="2000" />
      <label for="containerHeightRange">Height:</label>
      <input type="range" id="containerHeightRange" min="1000" max="5000" value="2000" />
    </div>

    <!-- (3) Row for Connectors, Colors, Save/Load, Z-index -->
    <div class="control-row">
      <button id="drawConnectorBtn">Draw Connector</button>
      <button id="clearConnectorsBtn">Clear Connectors</button>
      <label for="connectorColorInput">Connector Color:</label>
      <input type="color" id="connectorColorInput" value="#333333" />
      <input type="range" id="connectorAlphaRange" class="opacity-range" min="0" max="100" value="100" />
      <button id="saveChartBtn">Save Chart</button>
      <button id="loadChartBtn">Load Chart</button>
      <input type="file" id="loadFile" accept="application/json" style="display: none;" />
      <button id="bringFrontBtn">Bring to Front</button>
      <button id="sendBackBtn">Send to Back</button>
    </div>

    <!-- (4) Row for Node Editing (inline, auto-save) -->
    <div class="control-row">
      <label>Name:</label>
      <input type="text" id="editNodeName" />
      <label>Title:</label>
      <input type="text" id="editNodeTitle" />
      <label>Color:</label>
      <input type="color" id="editNodeColor" value="#ffffff" />
      <label>Alpha:</label>
      <input type="range" id="editNodeAlpha" class="opacity-range" min="0" max="100" value="100" />
      <button id="deleteNodeBtn">Delete Node</button>
    </div>
  </div>

  <!-- Main container for the org chart -->
  <div id="orgChartContainer"></div>

  <script>
    /**
     * Each node: { id, name, title, x, y, width, height, colorHex, colorAlpha (0-100) }
     * Connectors: { from, to, seg1, seg2 }
     */
    let orgData = [
      { id: 1, name: "Alice", title: "CEO", x: 200, y: 70,  width:130, height:60, colorHex: "#ffffff", colorAlpha: 100 },
      { id: 2, name: "Bob",   title: "CTO", x: 100, y:220, width:130, height:60, colorHex: "#ffffff", colorAlpha: 100 },
      { id: 3, name: "Carol", title: "CFO", x: 300, y:220, width:130, height:60, colorHex: "#ffffff", colorAlpha: 100 },
    ];

    let nodeElements = {};
    let connectors = [];
    let isDrawingConnector = false;
    let startNodeId = null;

    /* Multi-select & multi-drag */
    let selectedNodes = new Set();
    let isDraggingNodes = false;
    let groupOffsets = {};

    /* Z-index layering */
    let maxZIndex = 1;

    /* Zoom */
    let currentScale = 1.0;

    const GRID_SIZE = 10;
    let connectorColorHex = "#333333";
    let connectorAlpha = 100;

    /* Node editing fields refs */
    const editNameInput = document.getElementById('editNodeName');
    const editTitleInput = document.getElementById('editNodeTitle');
    const editColorInput = document.getElementById('editNodeColor');
    const editAlphaInput = document.getElementById('editNodeAlpha');
    const deleteNodeBtn = document.getElementById('deleteNodeBtn');

    /***********************************************
     * CREATE / DRAW NODES
     ***********************************************/
    function createOrgNodes() {
      const container = document.getElementById('orgChartContainer');
      // Remove existing DOM elements
      Object.values(nodeElements).forEach(el => {
        if (el.parentNode) {
          el.parentNode.removeChild(el);
        }
      });
      nodeElements = {};

      // Build DOM from orgData
      orgData.forEach(node => {
        const nodeEl = document.createElement('div');
        nodeEl.classList.add('org-node');
        nodeEl.id = `node-${node.id}`;
        nodeEl.style.left = node.x + 'px';
        nodeEl.style.top = node.y + 'px';
        nodeEl.style.width = node.width + 'px';
        nodeEl.style.height = node.height + 'px';
        nodeEl.style.zIndex = 1;
        const rgba = hexAlphaToRGBA(node.colorHex || "#ffffff", node.colorAlpha ?? 100);
        nodeEl.style.backgroundColor = rgba;

        nodeEl.innerHTML = `
          <div class="name">${node.name}</div>
          <div class="title">${node.title}</div>
          <div class="resize-handle"></div>
        `;
        container.appendChild(nodeEl);
        nodeElements[node.id] = nodeEl;

        makeDraggable(nodeEl);
        makeResizable(nodeEl, node);

        // Single click => either connect or select
        nodeEl.addEventListener('click', (e) => {
          e.stopPropagation();
          if (isDrawingConnector) {
            handleConnectorClick(node.id);
          } else {
            handleNodeSelection(e, node.id);
          }
        });
      });
    }

    /***********************************************
     * CONNECTORS
     ***********************************************/
    function createConnector(nodeIdA, nodeIdB) {
      const seg1 = document.createElement('div');
      seg1.classList.add('connector-segment');
      const seg2 = document.createElement('div');
      seg2.classList.add('connector-segment');

      seg1.style.backgroundColor = hexAlphaToRGBA(connectorColorHex, connectorAlpha);
      seg2.style.backgroundColor = hexAlphaToRGBA(connectorColorHex, connectorAlpha);

      const container = document.getElementById('orgChartContainer');
      container.appendChild(seg1);
      container.appendChild(seg2);

      const connectorObj = { from: nodeIdA, to: nodeIdB, seg1, seg2 };
      connectors.push(connectorObj);
      updateConnectorPositions(connectorObj);
    }

    function handleConnectorClick(nodeId) {
      if (startNodeId === null) {
        startNodeId = nodeId;
      } else {
        if (startNodeId !== nodeId) {
          createConnector(startNodeId, nodeId);
        }
        startNodeId = null;
        isDrawingConnector = false;
      }
    }

    function updateConnectorPositions(conn) {
      const { from, to, seg1, seg2 } = conn;
      const containerRect = document.getElementById('orgChartContainer').getBoundingClientRect();
      const elA = nodeElements[from].getBoundingClientRect();
      const elB = nodeElements[to].getBoundingClientRect();

      // Center points
      const centerA = {
        x: elA.left - containerRect.left + elA.width / 2,
        y: elA.top - containerRect.top + elA.height / 2
      };
      const centerB = {
        x: elB.left - containerRect.left + elB.width / 2,
        y: elB.top - containerRect.top + elB.height / 2
      };

      // Horizontal segment
      const left1 = Math.min(centerA.x, centerB.x);
      const width1 = Math.abs(centerB.x - centerA.x);
      seg1.style.left = left1 + 'px';
      seg1.style.top = centerA.y + 'px';
      seg1.style.width = width1 + 'px';
      seg1.style.height = '2px';
      seg1.style.backgroundColor = hexAlphaToRGBA(connectorColorHex, connectorAlpha);

      // Vertical segment
      const top2 = Math.min(centerA.y, centerB.y);
      const height2 = Math.abs(centerB.y - centerA.y);
      seg2.style.left = centerB.x + 'px';
      seg2.style.top = top2 + 'px';
      seg2.style.width = '2px';
      seg2.style.height = height2 + 'px';
      seg2.style.backgroundColor = hexAlphaToRGBA(connectorColorHex, connectorAlpha);
    }

    function updateAllConnectors() {
      connectors.forEach(conn => updateConnectorPositions(conn));
    }

    /***********************************************
     * SELECTION & MULTI-DRAG
     ***********************************************/
    function handleNodeSelection(e, nodeId) {
      const isMultiSelect = e.ctrlKey || e.metaKey;
      if (!isMultiSelect) {
        unselectAllNodes();
      }
      if (selectedNodes.has(nodeId) && isMultiSelect) {
        selectedNodes.delete(nodeId);
      } else {
        selectedNodes.add(nodeId);
      }
      updateSelectedStyles();
      updateEditFields(); // Refresh the inline editing state
    }

    function updateSelectedStyles() {
      Object.keys(nodeElements).forEach(idStr => {
        const idNum = parseInt(idStr, 10);
        if (selectedNodes.has(idNum)) {
          nodeElements[idNum].classList.add('selected');
        } else {
          nodeElements[idNum].classList.remove('selected');
        }
      });
    }

    function unselectAllNodes() {
      selectedNodes.clear();
      updateSelectedStyles();
      updateEditFields();
    }

    function makeDraggable(nodeEl) {
      const nodeId = parseInt(nodeEl.id.replace('node-',''),10);
      let isResizing = false;

      nodeEl.addEventListener('mousedown', (e) => {
        // If clicked the resize handle, do not drag
        if (e.target.classList.contains('resize-handle')) {
          isResizing = true;
          return;
        }
        isResizing = false;

        // Small delay so click selection is handled
        setTimeout(() => {
          if (selectedNodes.size > 0 && selectedNodes.has(nodeId)) {
            isDraggingNodes = true;
            groupOffsets = {};
            selectedNodes.forEach(selId => {
              const selEl = nodeElements[selId];
              groupOffsets[selId] = {
                offsetX: selEl.offsetLeft - e.clientX,
                offsetY: selEl.offsetTop - e.clientY
              };
            });
          }
        }, 0);
      });

      document.addEventListener('mouseup', () => {
        isDraggingNodes = false;
      });

      document.addEventListener('mousemove', (e) => {
        if (!isDraggingNodes) return;
        e.preventDefault();

        selectedNodes.forEach(selId => {
          const selEl = nodeElements[selId];
          let x = e.clientX + groupOffsets[selId].offsetX;
          let y = e.clientY + groupOffsets[selId].offsetY;

          // Snap to grid
          x = Math.round(x / GRID_SIZE) * GRID_SIZE;
          y = Math.round(y / GRID_SIZE) * GRID_SIZE;

          selEl.style.left = x + 'px';
          selEl.style.top = y + 'px';

          // Update data
          const theNode = orgData.find(n => n.id === selId);
          if (theNode) {
            theNode.x = x;
            theNode.y = y;
          }
        });
        updateAllConnectors();
      });
    }

    function makeResizable(nodeEl, nodeData) {
      const handle = nodeEl.querySelector('.resize-handle');
      if (!handle) return;
      let isResizing = false;
      let startWidth = 0, startHeight = 0;
      let startMouseX = 0, startMouseY = 0;

      handle.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        e.preventDefault();
        isResizing = true;
        startMouseX = e.clientX;
        startMouseY = e.clientY;
        startWidth = nodeEl.offsetWidth;
        startHeight = nodeEl.offsetHeight;
      });

      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        e.preventDefault();
        let newW = startWidth + (e.clientX - startMouseX);
        let newH = startHeight + (e.clientY - startMouseY);
        newW = Math.max(newW, 60);
        newH = Math.max(newH, 40);
        nodeEl.style.width = newW + 'px';
        nodeEl.style.height = newH + 'px';
        nodeData.width = newW;
        nodeData.height = newH;
        updateAllConnectors();
      });

      document.addEventListener('mouseup', () => {
        isResizing = false;
      });
    }

    /***********************************************
     * NODE EDITING (INLINE, AUTO-SAVE)
     ***********************************************/
    function updateEditFields() {
      const selCount = selectedNodes.size;

      if (selCount === 0) {
        // No node selected
        editNameInput.value = "Select node to edit attributes";
        editTitleInput.value = "Select node to edit attributes";
        editColorInput.value = "#ffffff";
        editAlphaInput.value = 100;

        editNameInput.disabled = true;
        editTitleInput.disabled = true;
        editColorInput.disabled = true;
        editAlphaInput.disabled = true;
        deleteNodeBtn.disabled = true;
        return;
      }

      if (selCount > 1) {
        // Multiple nodes
        editNameInput.value = "Cannot batch edit multiple nodes info";
        editTitleInput.value = "Cannot batch edit multiple nodes info";
        editColorInput.value = "#ffffff";
        editAlphaInput.value = 100;

        editNameInput.disabled = true;
        editTitleInput.disabled = true;
        editColorInput.disabled = true;
        editAlphaInput.disabled = true;
        deleteNodeBtn.disabled = true;
        return;
      }

      // Exactly one node
      const nodeId = Array.from(selectedNodes)[0];
      const node = orgData.find(n => n.id === nodeId);
      if (!node) return; // safety check

      editNameInput.value = node.name;
      editTitleInput.value = node.title;
      editColorInput.value = node.colorHex;
      editAlphaInput.value = node.colorAlpha;

      editNameInput.disabled = false;
      editTitleInput.disabled = false;
      editColorInput.disabled = false;
      editAlphaInput.disabled = false;
      deleteNodeBtn.disabled = false;
    }

    // Name changes => auto-update
    editNameInput.addEventListener('input', () => {
      if (selectedNodes.size === 1) {
        const nodeId = Array.from(selectedNodes)[0];
        const node = orgData.find(n => n.id === nodeId);
        if (node) {
          node.name = editNameInput.value;
          const nodeEl = nodeElements[nodeId];
          nodeEl.querySelector('.name').textContent = node.name;
        }
      }
    });
    // Title changes => auto-update
    editTitleInput.addEventListener('input', () => {
      if (selectedNodes.size === 1) {
        const nodeId = Array.from(selectedNodes)[0];
        const node = orgData.find(n => n.id === nodeId);
        if (node) {
          node.title = editTitleInput.value;
          const nodeEl = nodeElements[nodeId];
          nodeEl.querySelector('.title').textContent = node.title;
        }
      }
    });
    // Color changes => auto-update
    editColorInput.addEventListener('input', () => {
      if (selectedNodes.size === 1) {
        const nodeId = Array.from(selectedNodes)[0];
        const node = orgData.find(n => n.id === nodeId);
        if (node) {
          node.colorHex = editColorInput.value;
          const nodeEl = nodeElements[nodeId];
          nodeEl.style.backgroundColor = hexAlphaToRGBA(node.colorHex, node.colorAlpha);
        }
      }
    });
    // Alpha changes => auto-update
    editAlphaInput.addEventListener('input', () => {
      if (selectedNodes.size === 1) {
        const nodeId = Array.from(selectedNodes)[0];
        const node = orgData.find(n => n.id === nodeId);
        if (node) {
          node.colorAlpha = parseInt(editAlphaInput.value, 10);
          const nodeEl = nodeElements[nodeId];
          nodeEl.style.backgroundColor = hexAlphaToRGBA(node.colorHex, node.colorAlpha);
        }
      }
    });

    // Delete Node
    deleteNodeBtn.addEventListener('click', () => {
      if (selectedNodes.size !== 1) return;
      const nodeId = Array.from(selectedNodes)[0];
      // Remove from orgData
      orgData = orgData.filter(n => n.id !== nodeId);

      // Remove connectors referencing this node
      connectors.forEach(conn => {
        if (conn.from === nodeId || conn.to === nodeId) {
          if (conn.seg1 && conn.seg1.parentNode) conn.seg1.parentNode.removeChild(conn.seg1);
          if (conn.seg2 && conn.seg2.parentNode) conn.seg2.parentNode.removeChild(conn.seg2);
        }
      });
      connectors = connectors.filter(conn => conn.from !== nodeId && conn.to !== nodeId);

      // Remove DOM element
      const nodeEl = nodeElements[nodeId];
      if (nodeEl && nodeEl.parentNode) {
        nodeEl.parentNode.removeChild(nodeEl);
      }
      delete nodeElements[nodeId];

      unselectAllNodes(); 
      updateAllConnectors();
    });

    /***********************************************
     * Z-INDEX / LAYERING
     ***********************************************/
    function bringSelectedNodesToFront() {
      if (selectedNodes.size === 0) return;
      selectedNodes.forEach(selId => {
        maxZIndex++;
        nodeElements[selId].style.zIndex = maxZIndex;
      });
    }

    function sendSelectedNodesToBack() {
      if (selectedNodes.size === 0) return;
      selectedNodes.forEach(selId => {
        nodeElements[selId].style.zIndex = 1;
      });
    }

    /***********************************************
     * ZOOM
     ***********************************************/
    function zoomIn() {
      currentScale += 0.1;
      if (currentScale > 3.0) {
        currentScale = 3.0; // optional max
      }
      updateZoom();
    }
    function zoomOut() {
      currentScale -= 0.1;
      if (currentScale < 0.1) {
        currentScale = 0.1; // optional min
      }
      updateZoom();
    }
    function updateZoom() {
      const container = document.getElementById('orgChartContainer');
      container.style.transformOrigin = 'top left';
      container.style.transform = `scale(${currentScale})`;
    }

    /***********************************************
     * OTHER CHART UTILITIES
     ***********************************************/
    function addNewNode() {
      const maxId = orgData.reduce((m, n) => Math.max(m, n.id), 0);
      const newId = maxId + 1;
      const newNodeData = {
        id: newId,
        name: `Node ${newId}`,
        title: "",
        x: 50,
        y: 50,
        width: 130,
        height: 60,
        colorHex: "#ffffff",
        colorAlpha: 100
      };
      orgData.push(newNodeData);
      createOrgNodes();
      updateAllConnectors();
    }

    function autoOrganize() {
      let xStart = 50;
      let yStart = 50;
      const xGap = 200;
      const yGap = 150;
      orgData.forEach((node, index) => {
        const row = Math.floor(index / 3);
        const col = index % 3;
        node.x = xStart + col * xGap;
        node.y = yStart + row * yGap;
      });
      createOrgNodes();
      updateAllConnectors();
    }

    function clearAllConnectors() {
      connectors.forEach(conn => {
        if (conn.seg1 && conn.seg1.parentNode) {
          conn.seg1.parentNode.removeChild(conn.seg1);
        }
        if (conn.seg2 && conn.seg2.parentNode) {
          conn.seg2.parentNode.removeChild(conn.seg2);
        }
      });
      connectors = [];
    }

    function exportToPDF() {
      const container = document.getElementById('orgChartContainer');
      html2canvas(container).then(canvas => {
        const imgData = canvas.toDataURL('image/png');
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({ orientation: 'landscape', unit: 'px', format: 'a4' });
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        const ratio = Math.min(pageWidth / canvas.width, pageHeight / canvas.height);
        const imgWidth = canvas.width * ratio;
        const imgHeight = canvas.height * ratio;
        pdf.addImage(imgData, 'PNG', 0, 0, imgWidth, imgHeight);
        pdf.save('orgchart.pdf');
      });
    }

    function saveChart() {
      const connectorPairs = connectors.map(conn => ({ from: conn.from, to: conn.to }));
      const chartObject = { orgData, connectorPairs };
      const jsonStr = JSON.stringify(chartObject, null, 2);
      const blob = new Blob([jsonStr], { type: "application/json" });
      const blobUrl = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = blobUrl;
      link.download = "orgchart.json";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    function loadChartFromJSON(jsonStr) {
      try {
        const parsed = JSON.parse(jsonStr);
        if (!parsed.orgData || !parsed.connectorPairs) {
          alert("Invalid file format. Missing necessary fields.");
          return;
        }
        clearAllConnectors();
        orgData = parsed.orgData;
        createOrgNodes();
        connectors = [];
        parsed.connectorPairs.forEach(cp => {
          createConnector(cp.from, cp.to);
        });
        updateAllConnectors();
      } catch (err) {
        alert("Error reading file. Ensure it's valid JSON.\n" + err);
      }
    }

    function autoSizeAllNodes() {
      orgData.forEach(node => {
        const nodeEl = nodeElements[node.id];
        nodeEl.style.width = 'auto';
        nodeEl.style.height = 'auto';
        const newW = nodeEl.offsetWidth;
        const newH = nodeEl.offsetHeight;
        node.width = newW;
        node.height = newH;
        nodeEl.style.width = newW + 'px';
        nodeEl.style.height = newH + 'px';
      });
      updateAllConnectors();
    }

    /***********************************************
     * INITIAL SETUP
     ***********************************************/
    createOrgNodes();
    // Start with editing fields locked
    updateEditFields();

    // ================== BUTTON HANDLERS ==================
    document.getElementById('newNodeBtn').addEventListener('click', addNewNode);
    document.getElementById('autoOrganizeBtn').addEventListener('click', autoOrganize);
    document.getElementById('autoSizeBtn').addEventListener('click', autoSizeAllNodes);
    document.getElementById('exportPDFBtn').addEventListener('click', exportToPDF);

    document.getElementById('drawConnectorBtn').addEventListener('click', () => {
      isDrawingConnector = !isDrawingConnector;
      if (isDrawingConnector) {
        startNodeId = null;
      }
    });
    document.getElementById('clearConnectorsBtn').addEventListener('click', clearAllConnectors);

    document.getElementById('connectorColorInput').addEventListener('input', (e) => {
      connectorColorHex = e.target.value;
      updateAllConnectors();
    });
    document.getElementById('connectorAlphaRange').addEventListener('input', (e) => {
      connectorAlpha = parseInt(e.target.value, 10);
      updateAllConnectors();
    });

    document.getElementById('saveChartBtn').addEventListener('click', saveChart);
    document.getElementById('loadChartBtn').addEventListener('click', () => {
      document.getElementById('loadFile').click();
    });
    document.getElementById('loadFile').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (evt) => {
        loadChartFromJSON(evt.target.result);
      };
      reader.readAsText(file);
      e.target.value = "";
    });

    // Zoom
    document.getElementById('zoomOutBtn').addEventListener('click', zoomOut);
    document.getElementById('zoomInBtn').addEventListener('click', zoomIn);

    // Container Dimension Sliders
    const widthSlider = document.getElementById('containerWidthRange');
    const heightSlider = document.getElementById('containerHeightRange');
    widthSlider.addEventListener('input', (e) => {
      document.getElementById('orgChartContainer').style.width = e.target.value + 'px';
    });
    heightSlider.addEventListener('input', (e) => {
      document.getElementById('orgChartContainer').style.height = e.target.value + 'px';
    });

    // Z-Index
    document.getElementById('bringFrontBtn').addEventListener('click', bringSelectedNodesToFront);
    document.getElementById('sendBackBtn').addEventListener('click', sendSelectedNodesToBack);

    /* 1) Helper: Convert hex+alpha to RGBA string */
    function hexAlphaToRGBA(hex, alphaVal) {
      if (!hex.startsWith("#")) return "rgba(0,0,0,1)";
      let r = parseInt(hex.slice(1,3), 16);
      let g = parseInt(hex.slice(3,5), 16);
      let b = parseInt(hex.slice(5,7), 16);
      let a = alphaVal / 100.0;
      return `rgba(${r},${g},${b},${a})`;
    }

    /* 2) NEW: If the user clicks anywhere NOT on a node (and not on the controls), unselect all nodes */
    document.addEventListener('click', (e) => {
      // If user clicked outside any .org-node and also not on the #controls panel => unselect
      if (!e.target.closest('.org-node') && !e.target.closest('#controls')) {
        unselectAllNodes();
      }
    });
  </script>
</body>
</html>
